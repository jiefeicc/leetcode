# 刷题笔记

## 1.数据结构

### 1.链表

#### 206.反转链表

#### 25.K个一组翻转链

#### 160.相交链表

#### 143.重排链表

#### 23.合并K个升序链表



### 2.树

#### 103.二叉树的锯齿形层序遍历

#### 199.二叉树的右视图

#### 236.二叉树的最近公共祖先



### 3.LRU

#### 146.LRU 缓存机制

### 4.单调栈

#### 42:接雨水

### 5.数组

#### 31:下一个排列



## 2.算法

### 1.动态规划

#### 1.股票问题

##### 121.买卖股票的最佳时机（k = 1）

##### 122.买卖股票的最佳时机 II（k = +infinity）

##### 309.最佳买卖股票时机含冷冻期（k = +infinity with cooldown）

##### 714.买卖股票的最佳时机含手续费（k = +infinity with fee）

##### 123.买卖股票的最佳时机III（k = 2）

##### 188.买卖股票的最佳时机 IV（k = any integer）



### 2.n指针

#### 15.三数之和



### 3.二分法

#### 33.搜索旋转排序数组



### 4.排序

#### 1.快排

##### 215.数组中的第K个最大元素



### 5.滑动窗口

#### 3.无重复字符的最长子串



### 6.DFS/BFS

#### 1.岛屿类问题

首先二叉树DFS遍历框架

```java
public void dfs(TreeNode root) {
	if(root == null) {
        return;
    }
    //做处理
    traverse(root.left)
    traverse(root.right)
}
```

网格遍历框架

```java
public void dfs(char[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return;
    }
    // 做处理
    // 不是岛屿直接返回
    if (grid[r][c] != '1') {
        return;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = '2';

    // 访问上下左右四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
public boolean inArea(char[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```

##### 200.岛屿数量

思路：

```html
遍历“图“的每一个节点
遇到一个是岛屿就res++
然后从该节点开始dfs，将属于该岛屿的节点都标记为已经遍历 grid[r][c] = '2'
最终res++就是岛屿数量
```

```java
public int numIslands(char[][] grid) {
    int res = 0;
    for (int i=0; i<grid.length; i++) {
        for (int j=0; j< grid[0].length; j++) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j);
                res++;
            }
        }
    }
    return res;
}
public void dfs(char[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return;
    }
    // 做处理
    // 不是岛屿直接返回
    if (grid[r][c] != '1') {
        return;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = '2';

    // 访问上下左右四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
public boolean inArea(char[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```









## 3.设计模式

### 1.生产者消费者
