# 刷题笔记

<img src="https://img-blog.csdn.net/20180928135003419?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlZF9jcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" style="zoom:70%;" />

<img src="https://img-blog.csdn.net/2018092813475186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlZF9jcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" style="zoom: 70%;" />

## 数据结构

### 链表

#### 206.反转链表

```java
class Solution {
     /* 迭代解法
     pre->null,cur->head
     cur.next->pre
     迭代每个节点，完成翻转
      */
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        //用tmp记录cur的右边节点，防止反转cur之后找不到右边节点
        ListNode tmp;
        while (cur!=null) {
            tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    // 递归解法
    public ListNode _reverseList(ListNode head) {
        // head 为空时，不做处理
        if (head == null) {
            return head;
        }
        // 递归返回条件，到最后一个节点时开始返回
        if (head.next == null) {
            return head;
        }
        ListNode cur = _reverseList(head.next);
        // 从倒数第二个节点后面的链表开始处理
        // 建立反向指针
        head.next.next = head;
        // 防止环形链表，断开正向指针
        head.next = null;
        // 返回处理好的部分
        return cur;
    }
}
```



#### 96.反转链表 II

```java
class Solution {
    /*
     双指针(guard + point) + 头插法
     将guard移动到待翻转节点前一个，point移动到待翻转节点
     将point后面一个节点插入到guard后面
     重复上一步操作m-n次
     */
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode g = dummyHead;
        ListNode p = dummyHead.next;
        // 将guard移动到待翻转节点前一个，point移动到待翻转节点
        for (int i=0; i<m-1; i++) {
            g = g.next;
            p = p.next;
        }
        for (int i=0; i<n-m; i++) {
            insertHead(g, p);
        }
        return dummyHead.next;
    }
    // 将point后面一个节点插入到guard后面
    public void insertHead(ListNode guard, ListNode point) {
        // 记住point后面的节点
        ListNode removed = point.next;
        //删除point后面的节点
        point.next = point.next.next;

        //将point后面的节点插到guard后面
        removed.next = guard.next;
        guard.next = removed;
    }
}
```



#### 25.K个一组翻转链

```java
class Solution {
    /*
    定义两个 dummy 节点 pre 和 end
    end 往后移动 k 个节点，这 k 个节点单拿出来组成一个链表进行翻转，pre 设置到 end 的位置。
    重复上述操作，直到 end 节点往后移动不到 k 个节点。
     */
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode end = dummy;
        while (end.next != null) {
            for (int i=0; i<k&&end!=null; i++) {
                end = end.next;
            }
            if (end == null) {
                break;
            }
            // 记录断点并断开链表
            ListNode right = end.next;
            end.next = null;

            // 翻转这一段链表
            ListNode left = pre.next;
            pre.next = reverse(left);

            // left已经到了右边了，此时连接链表
            left.next = right;

            // pre 设置到 end 的位置
            pre = left;
            end = left;
        }
        return dummy.next;
    }
    // 不满 K 个也要翻转的处理方法
    public ListNode reverseKGroup1(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode end = dummy;
        ListNode tmp = null;
        while (end.next != null) {
            for (int i=0; i<k&&end!=null; i++) {
                // 原来逻辑不变，用一个tmp记录end
                tmp = end;
                end = end.next;
            }
            if (end == null) {
                // 当end到最后空节点时，把end移回最后的尾结点，不做break，而是对最后这段进行翻转
                end = tmp;
            }
            // 记录断点并断开链表
            ListNode right = end.next;
            end.next = null;

            // 翻转这一段链表
            ListNode left = pre.next;
            pre.next = reverse(left);

            // left已经到了右边了，此时连接链表
            left.next = right;

            // pre 设置到 end 的位置
            pre = left;
            end = left;
        }
        return dummy.next;
    }
    /*
    翻转链表
    cur = head，pre = null
    cur->pre，不停的往后迭代。
     */
    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        ListNode tmp;
        while (cur != null) {
            tmp = cur.next;
            cur.next = pre;

            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```



#### 160.相交链表

```java
public class Solution {
    // 走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            if (pA != null) {
                pA = pA.next;
            } else {
                pA = headB;
            }
            if (pB != null) {
                pB = pB.next;
            } else {
                pB = headA;
            }
        }
        return pA;
    }
}
```



#### 143.重排链表

```java
class Solution {
    /*
    双向队列解法
    除头节点外所有节点全部入队列
    节点出队列（先后再前）重建链表
     */
    public void reorderList(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) {
            return;
        }
        Deque<ListNode> deque = new LinkedList<>();
        // 入队列
        ListNode next= head.next;
        while (next != null) {
            deque.add(next);
            next = next.next;
        }
        // 出队列
        while (!deque.isEmpty()) {
            // 后出
            head.next = deque.removeLast();
            // 节点指针往后移位
            head = head.next;
            // 前出
            if (!deque.isEmpty()) {
                head.next = deque.removeFirst();
                // 节点指针往后移位
                head = head.next;
            }
        }
        // 断开尾结点的next，防止环形链表
        head.next = null;
    }
}
```



#### 21.合并两个有序链表

```java
class Solution {
    /*
    递归实现
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```



#### 23.合并K个升序链表

```java
class Solution {
    /*
    优先队列，小顶堆

    全部链表入队
    取出头节点最小的那个链表
    建立新链表
    取出得链表还有next节点，那就把next节点再入队

    最终效果就是pre节点依次连接从优先队列里面从小到大取出的节点
     */
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((v1,v2)->v1.val-v2.val);
        for (ListNode node : lists) {
            if (node != null){
                pq.add(node);
            }
        }
        ListNode dummyHead = new ListNode(0);
        ListNode pre = dummyHead;
        while (!pq.isEmpty()) {
            ListNode minNode = pq.poll();
            pre.next = minNode;
            pre = pre.next;
            if (minNode.next != null) {
                pq.add(minNode.next);
            }
        }
        return dummyHead.next;
    }

    // 归并解法
    public ListNode _mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }
    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left == right) return lists[left];
        int mid = left + (right - left) / 2;
        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);
        return mergeTwoLists(l1, l2);
    }
    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }

}
```



### 树

#### 103.二叉树的锯齿形层序遍历

```java
class Solution {
    /*
    广度优先搜索，通过flag控制在每层遍历时的方向
    queue.add(root)
    while(!queue.isEmpyt){
        int size = queue.size();
        for循环size次，每个size次为一层，根据flag确定插入方向
        for (int i=0; i<size; i++) {}
        res.add(linkedList),flag=!flag
    }
     */
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        boolean flag = true;
        queue.add(root);
        while (!queue.isEmpty()){
            // 通过size来一层一层的加入linkedList
            int size = queue.size();
            LinkedList<Integer> linkedList = new LinkedList<>();
            for (int i=0; i<size; i++) {
                TreeNode node = queue.remove();
                if (flag) {
                    linkedList.addLast(node.val);
                } else {
                    linkedList.addFirst(node.val);
                }

                if (node.left != null ) {
                    queue.add(node.left);
                }
                if (node.right != null ) {
                    queue.add(node.right);
                }
            }
            res.add(linkedList);
            flag = !flag;
        }
        return res;
    }
}
```



#### 199.二叉树的右视图

```java
class Solution {
    /*
     bfs 层次遍历
     每次进入while(!queue.isEmpty()),用一个size维护层次遍历
     每次层次遍历到(size-1)，这个就是要的右视图
     */
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i=0; i<size; i++) {
                TreeNode node = queue.poll();
                if (i == size-1) {
                    res.add(node.val);
                }
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        return res;
    }
}
```



#### 236.二叉树的最近公共祖先

```java
class Solution {
    /*
    后序遍历
    lowestCommonAncestor(root, p, q) 抽象理解为在root中找p或q的祖先
    如果 left 为空不是 p或q的祖先，那就返回 right
    如果 right 为空不是 p或q的祖先，那就返回 left
    如果 left 不为空且 right 不为空，那就说明 root 肯定是 p q 的公共祖先
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        // p或q是根节点，那根节点就肯定是 p q 的公共祖先
        if (root == p || root == q) {
            return root;
        }
        // 在root.left中找p或q的祖先
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        // 在root.right中找p或q的祖先
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 如果 left 为空不是 p或q的祖先，那 right 肯定是 p q 的祖先
        if (left == null) {
            return right;
        }
        // 如果 right 为空不是 p或q的祖先，那 left 肯定是 p q 的祖先
        if (right == null) {
            return left;
        }
        // left 不为空且 right 不为空，那就说明 root 肯定是 p q 的公共祖先
        return root;
    }
}
```



### LRU

#### 146.LRU 缓存机制

```java
/*
 通过map来实现get缓存逻辑
 通过双向链表来实现“最近最少使用”逻辑
 通过变量size来维护双向链表的长度
 记录head和tail这两个头尾连接的空节点方便操作
 get(key) {
    node = map.get(key)
    node 存在:
        moveToHead(node)
        return node.val
    不存在:
        return -1
 }
 put(key) {
    key不存在:
        构建node
        addToHead(node)
        size溢出:
            removeTail()
            从map移除
    存在:
        更新map和DLinkedNode的值
        moveToHead(node)
 }
 实现需要的方法:
     moveToHead(node)
     addToHead(node)
     removeTail()
     removeNode(node)
 */
class LRUCache {
    // 构造双向链表
    class DLinkedNode {
        int key;
        int val;
        DLinkedNode pre;
        DLinkedNode next;
        public DLinkedNode(){}
        public DLinkedNode(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
    // 初始化capacity，size
    // 构造cacheMap，还要构造headNode，tailNode这两个头尾连接的空节点方便使用。
    public Map<Integer, DLinkedNode> cacheMap = new HashMap<>();
    public int capacity;
    public int size;
    public DLinkedNode headNode;
    public DLinkedNode tailNode;
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        headNode = new DLinkedNode();
        tailNode = new DLinkedNode();
        headNode.next = tailNode;
        tailNode.pre = headNode;
    }
    public int get(int key) {
        DLinkedNode node = cacheMap.get(key);
        if (node != null) {
            moveToHead(node);
            return node.val;
        } else {
            return -1;
        }
    }
    public void put(int key, int value) {
        DLinkedNode node = cacheMap.get(key);
        if (node == null) {
            DLinkedNode linkedNode = new DLinkedNode(key, value);
            cacheMap.put(key, linkedNode);
            addToHead(linkedNode);
            size++;
            if (size > capacity) {
                // 移除非空尾节点，需要把该非空尾节点返回出来，方便map移除
                DLinkedNode tailPre = removeTail();
                cacheMap.remove(tailPre.key);
                size--;
            }
        } else {
            cacheMap.put(key, node);
            moveToHead(node);
            node.val = value;
        }
    }
    // 重建前后节点的连接，
    public void removeNode(DLinkedNode node) {
        DLinkedNode preNode = node.pre;
        DLinkedNode nextNode = node.next;
        preNode.next = nextNode;
        nextNode.pre = preNode;
    }
    // 移除空的尾节点tail前一个节点就行
    public DLinkedNode removeTail() {
        DLinkedNode tailPre = tailNode.pre;
        removeNode(tailPre);
        return tailPre;
    }
    // 插入到空的头节点 head 和其下一个节点中间即可
    public void addToHead(DLinkedNode node) {
        DLinkedNode headNext = headNode.next;
        headNode.next = node;
        node.pre = headNode;
        node.next = headNext;
        headNext.pre = node;
    }
    // removeNode(node) -> addToHead
    public void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
}
```



### 单调栈

#### 42:接雨水

```java
class Solution {
    /*
    单调栈解法
    https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/
    将数组索引操作进入单调栈
     */
    public int trap(int[] height) {
        int len = height.length;
        if (len == 0) {
            return 0;
        }
        Stack<Integer> stack = new Stack<>();
        int res = 0;
        for (int i=0; i<len; i++) {
            while (!stack.isEmpty() && height[stack.peek()] < height[i]) {
                int curIdx = stack.pop();
                while (!stack.isEmpty() && height[curIdx] == height[stack.peek()]) {
                    stack.pop();
                }
                if (!stack.isEmpty()) {
                    int stackTop = stack.peek();
                    res += (Math.min(height[stackTop], height[i]) - height[curIdx]) * (i - stackTop -1);
                }
            }
            stack.add(i);
        }
        return res;
    }
}
```



### 数组

#### 31:下一个排列

```java
class Solution {
    /*
    123465
    654321
     */
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if (len <= 1) {
            return;
        }
        for (int i = len-1; i>0; i--) {
            //从后往前找，找到最右边的升序
            if (nums[i] > nums[i-1]) {
                // 将最右边第一个比nums[i-1]大的数与nums[i-1]交换
                // 这个数肯定是右边最小的数，这个数最大就是nums[i]
                for (int j=len-1; j>=i; j--) {
                    if (nums[j] > nums[i-1]) {
                        swap(nums, i-1, j);
                        // 需要跳出for循环
                        break;
                    }
                }
                Arrays.sort(nums, i, len);
                return;
            }
        }
        Arrays.sort(nums);
    }
    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```



#### 54.螺旋矩阵

```java
class Solution {
    /*
    按照右下左上的顺序移动
    每次移动到了边界就重新设定边界
    边界超出就break
     */
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        // 数组为空直接返回
        if (matrix.length == 0) {
            return res;
        }
        // 设定上下左右四个边界
        int up = 0;
        int down = matrix.length-1;
        int left = 0;
        int right = matrix[0].length-1;
        while (true) {
            // 往右移动，当到最右边时停下来
            for (int col=left ; col<=right; col++) {
                res.add(matrix[up][col]);
            }
            // 重新设定上边界
            up++;
            // 若上边界超过下边界，跳出
            if (up > down) {
                break;
            }
            // 往下移
            for (int row=up ; row<=down; row++) {
                res.add(matrix[row][right]);
            }
            right--;
            if (right < left) {
                break;
            }
            // 往左移
            for (int col=right ; col>=left; col--) {
                res.add(matrix[down][col]);
            }
            down--;
            if (down < up) {
                break;
            }
            // 往上移
            for (int row=down ; row>=up; row--) {
                res.add(matrix[row][left]);
            }
            left++;
            if (left > right) {
                break;
            }
        }
        return res;
    }
}
```



## 算法

### 动态规划

#### 字符串问题

##### 300. 最长递增子序列

```java
class Solution {
    /*
    状态定义：dp[i] 的值代表 nums 以 nums[i] 结尾的最长子序列长度。
    转移方程：设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，做以下判断：
        if(nums[i]>nums[j]):
            nums[i] 可以接在nums[j] 之后,此情况下最长上升子序列长度为 dp[j] + 1。
        else:
            nums[i] 无法接在 nums[j] 之后，此情况上升子序列不成立，跳过。
    初始状态：dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
    返回值：dp 列表最大值
    */
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return len;
        }
        int[] dp = new int[len];
        Arrays.fill(dp,1);
        int res = 0;
        int pos = 0;
        for (int i=0; i<len; i++) {
            for (int j=0; j<i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j]+1);
                }
            }
            if (dp[i] >= res) {
                res = dp[i];
                pos = i;
            }
        }

        int posdp = res;
        List<Integer> list = new ArrayList<>();
        list.add(nums[pos]);
        for (int i=pos-1; i>=1; i--) {
            if (dp[i] == posdp-1) {
                list.add(nums[i]);
                posdp = dp[i];
            }
        }
        System.out.println(list);

        return res;
    }

    // 纸牌算法，二分
    public int _lengthOfLIS(int[] nums) {
        int[] top = new int[nums.length];
        // 牌堆数初始化为 0
        int piles = 0;
        for (int i = 0; i < nums.length; i++) {
            // 要处理的扑克牌
            int poker = nums[i];

            /***** 搜索左侧边界的二分查找 *****/
            int left = 0, right = piles;
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] > poker) {
                    right = mid;
                } else if (top[mid] < poker) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            /*********************************/

            // 没找到合适的牌堆，新建一堆
            if (left == piles) piles++;
            // 把这张牌放到牌堆顶
            top[left] = poker;
        }
        // 牌堆数就是 LIS 长度
        return piles;
    }
}
```



#### 股票问题

```java
// base case：
dp[-1][...][0] = dp[...][0][0] = 0            // i = -1 意味着还没有开始，这时候的利润是0。 k=0 意味着根本不允许交易，这时候利润是0。
dp[-1][...][1] = dp[...][0][1] = -infinity    // 还没开始的时候，是不可能持有股票的。不允许交易的情况下，是不可能持有股票的。因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值。 
// 状态转移⽅程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])     // ( 今天选择 rest, 今天选择 sell )
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])   // ( 今天选择 rest, 今天选择 buy  ) 
```

##### 121.买卖股票的最佳时机（k = 1）

```java
// k = 1
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])
// 解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。
// 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
// 可以进⾏进⼀步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

```java
// 原始版本
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case
            // 根据状态转移⽅程可得：
            // dp[i][0]
            // = max(dp[-1][0], dp[-1][1] + prices[i])
            // = max(0, -infinity + prices[i]) = 0
            dp[i][0] = 0;
            // 根据状态转移⽅程可得：
            // dp[i][1]
            // = max(dp[-1][1], dp[-1][0] - prices[i])
            // = max(-infinity, 0 - prices[i])
            // = -prices[i]
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        // dp[i][1] = max(dp[i-1][1], -prices[i])
        dp_i_1 = Math.max(dp_i_1, -prices[i]);
    }
    return dp_i_0;
}
```

##### 122.买卖股票的最佳时机 II（k = +infinity）

```java
// k = +infinity 
// 如果 k 为正⽆穷，那么就可以认为 k 和 k - 1 是⼀样的。可以这样改写框架：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
// 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
```

```java
// 原始版本
int maxProfit_k_inf(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_k_inf(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
    }
    return dp_i_0;
}
```

##### 309.最佳买卖股票时机含冷冻期（k = +infinity with cooldown）

```java
// k = +infinity with cooldown
// 参考K为正无穷
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
// 第 i 天选择 buy 的时候，要从 i-2 的状态转移，⽽不是 i-1 。
```

```java
// 原始版本
int maxProfit_with_cool(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case 1
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        if (i - 2 == -1) {
            // base case 2
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            // i - 2 ⼩于 0 时根据状态转移⽅程推出对应 base case
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
            // dp[i][1]
            // = max(dp[i-1][1], dp[-1][0] - prices[i])
            // = max(dp[i-1][1], 0 - prices[i])
            // = max(dp[i-1][1], -prices[i])
            continue;
        }
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_with_cool(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    int dp_pre_0 = 0; // 代表 dp[i-2][0]
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
        dp_pre_0 = temp;
    }
    return dp_i_0;
}
```

##### 714.买卖股票的最佳时机含手续费（k = +infinity with fee）

```java
// k = +infinity with fee
// 每次交易要⽀付⼿续费，只要把⼿续费从利润中减去即可。改写⽅程：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
// 相当于买⼊股票的价格升⾼了。
// 在第⼀个式⼦⾥减也是⼀样的，相当于卖出股票的价格减⼩了。
```

```java
// 原始版本
int maxProfit_with_fee(int[] prices, int fee) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i] - fee;
            // dp[i][1]
            // = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
            // = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
            // = max(-inf, 0 - prices[i] - fee)
            // = -prices[i] - fee
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_with_fee(int[] prices, int fee) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
    }
    return dp_i_0;
}
```

##### 123.买卖股票的最佳时机III（k = 2）

```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

```java
// 原始版本
int maxProfit_k_2(int[] prices) {
    int max_k = 2, n = prices.length;
    int[][][] dp = new int[n][max_k + 1][2];
    for (int i = 0; i < n; i++) {
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // 处理 base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
        }
    }
    // 穷举了 n × max_k × 2 个状态，正确。
    return dp[n - 1][max_k][0];
}
// 状态转移⽅程：
// dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
// dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
// dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
// dp[i][1][1] = max(dp[i-1][1][1], -prices[i])
// 空间复杂度优化版本
int maxProfit_k_2(int[] prices) {
    // base case
    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
    for (int price : prices) {
        dp_i20 = Math.max(dp_i20, dp_i21 + price);
        dp_i21 = Math.max(dp_i21, dp_i10 - price);
        dp_i10 = Math.max(dp_i10, dp_i11 + price);
        dp_i11 = Math.max(dp_i11, -price);
    }
    return dp_i20;
}
```

##### 188.买卖股票的最佳时机 IV（k = any integer）

```java
int maxProfit_k_any(int max_k, int[] prices) {
    int n = prices.length;
    if (n <= 0) {
        return 0;
    }
    if (max_k > n / 2) {
        // 交易次数 k 没有限制的情况
        return maxProfit_k_inf(prices);
    }
    // base case：
    // dp[-1][...][0] = dp[...][0][0] = 0
    // dp[-1][...][1] = dp[...][0][1] = -infinity
    int[][][] dp = new int[n][max_k + 1][2];
    // k = 0 时的 base case
    for (int i = 0; i < n; i++) {
        dp[i][0][1] = Integer.MIN_VALUE;
        dp[i][0][0] = 0;
    }
    for (int i = 0; i < n; i++)
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // 处理 i = -1 时的 base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
        }
    return dp[n - 1][max_k][0];
}
```



### n指针

#### 15.三数之和

```java
class Solution {
    /*
    三指针解法
    i=0,j=i+1,k=nums.len
     for (int i=0; i<length-2; i++){
        int temp = nums[i] + nums[j] + nums[k];
        temp > 0 k--
        temp < 0 j++
        temp = 0 res.add
            // 去重操作
            while(j<k && nums[j]=nums[j+1])
                j++
            while(j<k && nums[k]=nums[k-1])
                k--
     }
     */
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums.length<3) {
            return res;
        }
        Arrays.sort(nums);
        int length = nums.length;
        for (int i=0; i<length-2; i++){
            if (nums[i] > 0) {
                break;
            }
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int j = i + 1;
            int k = length-1;
            while (j<k) {
                int temp = nums[i] + nums[j] + nums[k];
                if (temp > 0) {
                    k--;
                } else if (temp < 0) {
                    j++;
                } else {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[k]);
                    res.add(list);
                    // 去重
                    while (j<k && nums[j]==nums[j+1]) {
                        j++;
                    }
                    while (j<k && nums[k]==nums[k-1]) {
                        k--;
                    }
                    k--;
                    j++;
                }
            }
        }
        return res;
    }
}
```



### 二分法

#### 33.搜索旋转排序数组

```java
1
```



### 排序

#### 快排

##### 215.数组中的第K个最大元素

```java
class Solution {
    /*
     旋转数组二分
     二分同时需要考虑mid在左右哪一段
     分四种情况
     例：5 6 7 8 9 0 1 2 3 4
     mid在左段（nums[lo]<=nums[mid]）:
        target在mid左边（nums[lo]<=target<nums[mid]）
        target在mid右边
     mid在右段:
        target在mid左边
        target在mid右边（nums[mid]<target<=nums[hi]）
     */
    public int search(int[] nums, int target) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo <= hi) {
            int mid = (lo + hi)/2;
            if (target == nums[mid]) {
                return mid;
            }
            if (nums[lo] <= nums[mid]) {
                if (nums[lo] <= target && target < nums[mid]) {
                    hi = mid -1;
                } else {
                    lo = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[hi]) {
                    lo = mid + 1;
                } else {
                    hi = mid -1;
                }
            }
        }
        return -1;
    }
}
```



### 滑动窗口

#### 3.无重复字符的最长子串

```java
class Solution {
    /*
    abcabcbb
    滑动窗口

    低效率：使用s.contain来判断，用s的left,right截取来维持滑动窗口
    left,right维持一个窗口，max维护最大值
    right每次往前移动，然后拿出最新的那个字符c
    当最新的字符c包含在窗口里面，那就移动left直到窗口不包含c
    !s(left,right).contain(c) {
        max = Math.max(s(left,right+1).len,max)
    } else {
        while(!s(left,right).contain(c)) {
            left++;
        }
    }

    高效率：使用map.contain来判断，使用left,right截取来维持滑动窗口，用map记录s.charAt(index),index
    right每次往前移动，然后拿出最新的那个字符c
    当最新的字符c包含在窗口里面，那就从map里面取出c的位置，left = index(c)+1，注意：c的位置可能在left的左边，所以要判断一下大小(abba)
    再放入最新的c，然后计算max
     */
    public int lengthOfLongestSubstring(String s) {
        int max = 0;
        Map<Character, Integer> map = new HashMap<>();
        for (int left = 0,right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            if (map.containsKey(c)) {
                // abba  c的位置可能在left的左边，所以要判断一下大小
                left = Math.max(map.get(c)+1, left);
            }
            // put之后会把原来的值覆盖了，map里面永远只有一个c
            map.put(c, right);
            max = Math.max(max, right-left+1);
        }
        return max;
    }

    public int lengthOfLongestSubstring1(String s) {
        int max = 0;
        for (int left = 0,right = 0; right < s.length(); right++) {
            String c = s.substring(right, right + 1);
            String String = s.substring(left, right);
            if (!String.contains(c)) {
                max = Math.max(String.length() + 1, max);
            } else {
                while (String.contains(c)) {
                    left++;
                    String = s.substring(left, right);
                }
            }
        }
        return max;
    }
}
```



#### 76.最小覆盖子串

```java
class Solution {
    public static String minWindow(String s, String t) {
        //首先创建的是need数组表示每个字符在t中需要的数量，用ASCII码来保存
        //加入need[76] = 2，表明ASCII码为76的这个字符在目标字符串t中需要两个，如果是负数表明当前字符串在窗口中是多余的，需要过滤掉
        int[] need = new int[128];
        //按照字符串t的内容向need中添加元素
        for (int i = 0; i < t.length(); i++) {
            need[t.charAt(i)]++;
        }
        /*
        l: 滑动窗口左边界
        r: 滑动窗口右边界
        size: 窗口的长度
        count: 当次遍历中还需要几个字符才能够满足包含t中所有字符的条件，最大也就是t的长度
        start: 如果有效更新滑动窗口，记录这个窗口的起始位置，方便后续找子串用
         */
        int l = 0, r = 0, minSize = Integer.MAX_VALUE, count = t.length(), start = 0;
        //循环条件右边界不超过s的长度
        while (r < s.length()) {
            char c = s.charAt(r);
            //表示t中包含当前遍历到的这个c字符，更新目前所需要的count数大小，应该减少一个
            if (need[c] > 0) {
                count--;
            }
            //无论这个字符是否包含在t中，need[]数组中对应那个字符的计数都减少1，利用正负区分这个字符是多余的还是有用的
            need[c]--;
            //count==0说明当前的窗口已经满足了包含t所需所有字符的条件
            if (count == 0) {
                //如果左边界这个字符对应的值在need[]数组中小于0，说明他是一个多余元素，不包含在t内
                while (l < r && need[s.charAt(l)] < 0) {
                    //在need[]数组中维护更新这个值，增加1
                    need[s.charAt(l)]++;
                    //左边界向右移，过滤掉这个元素
                    l++;
                }
                //如果当前的这个窗口值比之前维护的窗口值更小，需要进行更新
                if (r - l + 1 < minSize) {
                    //更新窗口值
                    minSize = r - l + 1;
                    //更新窗口起始位置，方便之后找到这个位置返回结果
                    start = l;
                }
                //先将l位置的字符计数重新加1
                need[s.charAt(l)]++;
                //重新维护左边界值和当前所需字符的值count
                l++;
                count++;
            }
            //右移边界，开始下一次循环
            r++;
        }
        return minSize == Integer.MAX_VALUE ? "" : s.substring(start, start + minSize);
    }

    /*
    滑动窗口解法
    hs 维护s字符串中滑动窗口中各个字符出现的次数
     */
    public String _minWindow(String s, String t) {
        // 维护s字符串中滑动窗口中各个字符出现的次数
        HashMap<Character,Integer> hs = new HashMap<Character,Integer>();
        // 维护t字符串各个字符出现多少次
        HashMap<Character,Integer> ht = new HashMap<Character,Integer>();
        // 遍历t字符串，用ht哈希表记录t字符串各个字符出现的次数。
        for(int i = 0;i < t.length();i ++){
            ht.put(t.charAt(i),ht.getOrDefault(t.charAt(i), 0) + 1);
        }
        String ans = "";
        int minLen = Integer.MAX_VALUE;
        // 有多少个元素符合
        int count = 0;
        for(int i = 0,j = 0;i < s.length();i ++) {
            hs.put(s.charAt(i), hs.getOrDefault(s.charAt(i), 0) + 1);
            if(ht.containsKey(s.charAt(i)) && hs.get(s.charAt(i)) <= ht.get(s.charAt(i))){
                count ++;
            }
            while(j < i && (!ht.containsKey(s.charAt(j)) || hs.get(s.charAt(j)) > ht.get(s.charAt(j)))) {
                hs.put(s.charAt(j), hs.get(s.charAt(j)) - 1);
                j++;
            }
            if(count == t.length() && i - j + 1 < minLen) {
                minLen = i - j + 1;
                ans = s.substring(j,i + 1);
            }
        }
        return ans;
    }
}
```




### DFS/BFS

#### 岛屿类问题

首先二叉树DFS遍历框架

```java
public void dfs(TreeNode root) {
	if(root == null) {
        return;
    }
    //做处理
    traverse(root.left)
    traverse(root.right)
}
```

网格遍历框架

```java
public void dfs(char[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return;
    }
    // 做处理
    // 不是岛屿直接返回
    if (grid[r][c] != '1') {
        return;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = '2';

    // 访问上下左右四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
public boolean inArea(char[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```

##### 200.岛屿数量

思路：

```html
遍历“图“的每一个节点
遇到一个是岛屿就res++
然后从该节点开始dfs，将属于该岛屿的节点都标记为已经遍历 grid[r][c] = '2'
最终res++就是岛屿数量
```

```java
public int numIslands(char[][] grid) {
    int res = 0;
    for (int i=0; i<grid.length; i++) {
        for (int j=0; j< grid[0].length; j++) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j);
                res++;
            }
        }
    }
    return res;
}
public void dfs(char[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return;
    }
    // 做处理
    // 不是岛屿直接返回
    if (grid[r][c] != '1') {
        return;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = '2';

    // 访问上下左右四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
public boolean inArea(char[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```

##### 695.岛屿的最大面积

思路：

```html
遍历“图“的每一个节点
遇到一个是岛屿就从该节点开始dfs，将属于该岛屿的节点都标记为已经遍历 grid[r][c] = '2'
dfs过程中不符合的（超出边界，不是岛屿）直接返回0
进入方法并且判断过没有超出边界，然后还判断了是岛屿，那面积就是 1 + dfs(上) + dfs(下) + dfs(左) + dfs(右);
```

```java
public int maxAreaOfIsland(int[][] grid) {
    int max = 0;
    for (int i=0; i<grid.length; i++) {
        for (int j=0; j< grid[0].length; j++) {
            if (grid[i][j] == 1) {
                int area = dfs(grid, i, j);
                max = Math.max(area, max);
            }
        }
    }
    return max;
}
public int dfs(int[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return 0;
    }
    // 不是岛屿返回0
    if (grid[r][c] != 1) {
        return 0;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = 2;

    // 访问上下左右四个节点
    // 进入方法并且判断过没有超出边界，然后还判断了是岛屿，那面积就是 1 + dfs(上) + dfs(下) + dfs(左) + dfs(右);
    return 1 + dfs(grid, r - 1, c)
        +dfs(grid, r + 1, c)
        +dfs(grid, r, c - 1)
        +dfs(grid, r, c + 1);
}
public boolean inArea(int[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```





## 设计模式

### 生产者消费者

```java

```

