# 刷题笔记

## 时间空间复杂度及稳定性

<img src="https://img-blog.csdn.net/20180928135003419?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlZF9jcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" style="zoom:70%;" />

<img src="C:\Users\zhuwenjin\AppData\Roaming\Typora\typora-user-images\image-20220108002051055.png" alt="image-20220108002051055" style="zoom:45%;" />

<img src="https://img-blog.csdn.net/2018092813475186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlZF9jcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" style="zoom: 90%;" />

## 数据结构

### 链表

#### [206.反转链表](https://leetcode-cn.com/problems/reverse-linked-list)

```java
class Solution {
     /* 迭代解法
     pre->null,cur->head
     cur.next->pre
     迭代每个节点，完成翻转
      */
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        //用tmp记录cur的右边节点，防止反转cur之后找不到右边节点
        ListNode tmp;
        while (cur!=null) {
            tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    // 递归解法
    public ListNode _reverseList(ListNode head) {
        // head 为空时，不做处理
        if (head == null) {
            return head;
        }
        // 递归返回条件，到最后一个节点时开始返回
        if (head.next == null) {
            return head;
        }
        ListNode cur = _reverseList(head.next);
        // 从倒数第二个节点后面的链表开始处理
        // 建立反向指针
        head.next.next = head;
        // 防止环形链表，断开正向指针
        head.next = null;
        // 返回处理好的部分
        return cur;
    }
}
```



#### [96.反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii)

```java
class Solution {
    /*
     双指针(guard + point) + 头插法
     将guard移动到待翻转节点前一个，point移动到待翻转节点
     将point后面一个节点插入到guard后面
     重复上一步操作m-n次
     */
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode g = dummyHead;
        ListNode p = dummyHead.next;
        // 将guard移动到待翻转节点前一个，point移动到待翻转节点
        for (int i=0; i<m-1; i++) {
            g = g.next;
            p = p.next;
        }
        for (int i=0; i<n-m; i++) {
            insertHead(g, p);
        }
        return dummyHead.next;
    }
    // 将point后面一个节点插入到guard后面
    public void insertHead(ListNode guard, ListNode point) {
        // 记住point后面的节点
        ListNode removed = point.next;
        //删除point后面的节点
        point.next = point.next.next;

        //将point后面的节点插到guard后面
        removed.next = guard.next;
        guard.next = removed;
    }
}
```



#### [25.K个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)

```java
class Solution {
    /*
    定义两个 dummy 节点 pre 和 end
    end 往后移动 k 个节点，这 k 个节点单拿出来组成一个链表进行翻转，pre 设置到 end 的位置。
    重复上述操作，直到 end 节点往后移动不到 k 个节点。
     */
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode end = dummy;
        while (end.next != null) {
            for (int i=0; i<k&&end!=null; i++) {
                end = end.next;
            }
            if (end == null) {
                break;
            }
            // 记录断点并断开链表
            ListNode right = end.next;
            end.next = null;

            // 翻转这一段链表
            ListNode left = pre.next;
            pre.next = reverse(left);

            // left已经到了右边了，此时连接链表
            left.next = right;

            // pre 设置到 end 的位置
            pre = left;
            end = left;
        }
        return dummy.next;
    }
    // 不满 K 个也要翻转的处理方法
    public ListNode reverseKGroup1(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode end = dummy;
        ListNode tmp = null;
        while (end.next != null) {
            for (int i=0; i<k&&end!=null; i++) {
                // 原来逻辑不变，用一个tmp记录end
                tmp = end;
                end = end.next;
            }
            if (end == null) {
                // 当end到最后空节点时，把end移回最后的尾结点，不做break，而是对最后这段进行翻转
                end = tmp;
            }
            // 记录断点并断开链表
            ListNode right = end.next;
            end.next = null;

            // 翻转这一段链表
            ListNode left = pre.next;
            pre.next = reverse(left);

            // left已经到了右边了，此时连接链表
            left.next = right;

            // pre 设置到 end 的位置
            pre = left;
            end = left;
        }
        return dummy.next;
    }
    /*
    翻转链表
    cur = head，pre = null
    cur->pre，不停的往后迭代。
     */
    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        ListNode tmp;
        while (cur != null) {
            tmp = cur.next;
            cur.next = pre;

            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```



#### [160.相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)

```java
public class Solution {
    // 走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            if (pA != null) {
                pA = pA.next;
            } else {
                pA = headB;
            }
            if (pB != null) {
                pB = pB.next;
            } else {
                pB = headA;
            }
        }
        return pA;
    }
}
```



#### [143.重排链表](https://leetcode-cn.com/problems/reorder-list)

```java
class Solution {
    /*
    双向队列解法
    除头节点外所有节点全部入队列
    节点出队列（先后再前）重建链表
     */
    public void reorderList(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) {
            return;
        }
        Deque<ListNode> deque = new LinkedList<>();
        // 入队列
        ListNode next= head.next;
        while (next != null) {
            deque.add(next);
            next = next.next;
        }
        // 出队列
        while (!deque.isEmpty()) {
            // 后出
            head.next = deque.removeLast();
            // 节点指针往后移位
            head = head.next;
            // 前出
            if (!deque.isEmpty()) {
                head.next = deque.removeFirst();
                // 节点指针往后移位
                head = head.next;
            }
        }
        // 断开尾结点的next，防止环形链表
        head.next = null;
    }
}
```



#### [21.合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)

```java
class Solution {
    /*
    递归实现
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```



#### [23.合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists)

```java
class Solution {
    /*
    优先队列，小顶堆

    全部链表入队
    取出头节点最小的那个链表
    建立新链表
    取出得链表还有next节点，那就把next节点再入队

    最终效果就是pre节点依次连接从优先队列里面从小到大取出的节点
     */
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((v1,v2)->v1.val-v2.val);
        for (ListNode node : lists) {
            if (node != null){
                pq.add(node);
            }
        }
        ListNode dummyHead = new ListNode(0);
        ListNode pre = dummyHead;
        while (!pq.isEmpty()) {
            ListNode minNode = pq.poll();
            pre.next = minNode;
            pre = pre.next;
            if (minNode.next != null) {
                pq.add(minNode.next);
            }
        }
        return dummyHead.next;
    }

    // 归并解法
    public ListNode _mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }
    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left == right) return lists[left];
        int mid = left + (right - left) / 2;
        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);
        return mergeTwoLists(l1, l2);
    }
    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }

}
```



#### [148.排序链表](https://leetcode-cn.com/problems/sort-list/)

```java
class Solution {
    /*
     归并（递归）
     */
    public ListNode _sortList(ListNode head) {
        // 1、递归结束条件
        if (head == null || head.next == null) {
            return head;
        }
        // 2、找到链表中间节点并断开链表 & 递归下探
        ListNode midNode = middleNode(head);
        ListNode rightHead = midNode.next;
        midNode.next = null;

        ListNode left = _sortList(head);
        ListNode right = _sortList(rightHead);

        // 3、当前层业务操作（合并有序链表）
        return mergeTwoLists(left, right);
    }
    //  找到链表中间节点（876. 链表的中间结点）
    private ListNode middleNode(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode slow = head;
        ListNode fast = head.next.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    // 合并两个有序链表（21. 合并两个有序链表）
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
    /*
    快排（递归）
     */
    public ListNode __sortList(ListNode head) {
        //边界
        if(head==null || head.next==null)  {
            return head;
        }
        //伪头结点
        ListNode pre=new ListNode(0,head);
        //快排
        quickSort(pre,null);
        //返回头结点
        return pre.next;
    }
    //输入时伪头结点和尾节点null
    void quickSort(ListNode pre,ListNode end){
        //如果节点数小于1就返回
        if(pre==end||pre.next==end||pre.next.next==end) {
            return;
        }
        //选第一个节点为基准
        ListNode b=pre.next;
        //建立临时链表
        ListNode cur=new ListNode(0);
        //临时左右两指针
        ListNode r=b;
        ListNode l=cur;
        //遍历，右指针下一节点为end，说明当前是最后一个元素，结束
        while(r.next!=end){
            //如果当前元素小于基准，就加入临时链表，并在原链表中删除
            if(r.next.val<b.val){
                l.next=r.next;
                l=l.next;
                r.next=r.next.next;
            } else{
                //不小于基准，右指针后移
                r=r.next;
            }
        }
        //临时链表接在原链表前面，并把伪头结点指向临时节点头结点
        l.next=pre.next;
        pre.next=cur.next;
        //对基准的左右两边递归，注意输入都是伪头结点和两链表的尾节点的下一节点
        quickSort(pre,b);
        quickSort(b,end);
    }
    /*
    迭代法
     */
    public ListNode sortList(ListNode head) {
        int length = getLength(head);
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        for(int step = 1; step < length; step*=2){ //依次将链表分成1块，2块，4块...
            //每次变换步长，pre指针和cur指针都初始化在链表头
            ListNode pre = dummy;
            ListNode cur = dummy.next;
            while(cur!=null){
                ListNode h1 = cur; //第一部分头 （第二次循环之后，cur为剩余部分头，不断往后把链表按照步长step分成一块一块...）
                ListNode h2 = split(h1,step);  //第二部分头
                cur = split(h2,step); //剩余部分的头
                ListNode temp = merge(h1,h2); //将一二部分排序合并
                pre.next = temp; //将前面的部分与排序好的部分连接
                while(pre.next!=null){
                    pre = pre.next; //把pre指针移动到排序好的部分的末尾
                }
            }
        }
        return dummy.next;
    }
    public int getLength(ListNode head){
        //获取链表长度
        int count = 0;
        while(head!=null){
            count++;
            head=head.next;
        }
        return count;
    }
    public ListNode split(ListNode head,int step){
        //断链操作 返回第二部分链表头
        if(head==null)  return null;
        ListNode cur = head;
        for(int i=1; i<step && cur.next!=null; i++){
            cur = cur.next;
        }
        ListNode right = cur.next;
        cur.next = null; //切断连接
        return right;
    }
    public ListNode merge(ListNode h1, ListNode h2){
        //合并两个有序链表
        ListNode head = new ListNode(-1);
        ListNode p = head;
        while(h1!=null && h2!=null){
            if(h1.val < h2.val){
                p.next = h1;
                h1 = h1.next;
            }
            else{
                p.next = h2;
                h2 = h2.next;
            }
            p = p.next;
        }
        if(h1!=null)    p.next = h1;
        if(h2!=null)    p.next = h2;

        return head.next;
    }
}
```



#### [83.删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)

```java
class Solution {
    // 1 2 2 2 3 3 4
    public ListNode deleteDuplicates(ListNode head) {
        ListNode cur = head;
        while(cur != null && cur.next != null) {
            // 当cur 和 cur.next 值一样，直接把cur.next卡掉
            if(cur.val == cur.next.val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        return head;
    }
}
```

#### [82.删除排序链表中的重复元素II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)

```java
class Solution {
    /*
    双指针 pre,cur
    if(pre.next.val!=cur.next.val)
        pre和cur都后移
    else
        //当cur、pre指向的节点值相等，就不断后移cur，直到cur、pre指向的值不相等
        while(cur.next!=null && pre.next.val==cur.next.val)
            cur后移
        pre.next = cur.next，这一步直接把所有重复的节点卡掉了，1222334->14
        cur = cur.next
        注：pre不能后移，因为pre下一个节点可能也要去掉
     */
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null) {
            return head;
        }
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur!=null && cur.next!=null) {
            //初始化的时cur指向的是哑结点，所以比较逻辑应该是cur的下一个节点和pre的下一个节点
            if(pre.next.val!=cur.next.val) {
                pre = pre.next;
                cur = cur.next;
            }
            else {
                //当cur、pre指向的节点值相等，就不断后移cur，直到cur、pre指向的值不相等
                while(cur.next!=null && pre.next.val==cur.next.val) {
                    cur = cur.next;
                }
                pre.next = cur.next;
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
```

#### [141.环形链表](https://leetcode-cn.com/problems/linked-list-cycle)

```java
public class Solution {
    /*
    快慢指针
    slow = head，fast = head.next
    当不超过边界，slow = slow.next，fast = fast.next.next
    如果环形链表，两个节点肯定会相遇
     */
    public boolean hasCycle(ListNode head) {
        if (head == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow.next != null && fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
```

#### [142.环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii)

```java
public class Solution {
    /*
    设链表共 a+b 个节点，链表头部到链表入口有 a 个节点（不包含链表入口），链表环有 b 个节点

    fast 追上 slow时：
    设fast走f步，slow走s步
    fast 走的步数是slow步数的 2 倍，即 f = 2s
    fast 追上 slow，f=s+nb
    （f = 2s，f=s+nb）得 s=nb，f=2nb
    从head走到链表入口节点时的步数 是：a+nb
    slow已经走了nb，那么slow再走a步就是入环点了

    重新构建一个从头开始的指针temp，往前走a步到入口，slow也往前走a步，最终两节点在入口相遇
     */
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (slow.next != null && fast.next!=null && fast.next.next!=null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                ListNode temp = head;
                while (temp != slow) {
                    temp = temp.next;
                    slow = slow.next;
                }
                return temp;
            }
        }
        return null;
    }
}
```

#### [2.两数相加](https://leetcode-cn.com/problems/add-two-numbers)

```java
class Solution {
    /*
    迭代两个链表
    维护一个进位 carry
    两个节点和进位相加 得到节点值和新进位
    迭代下去
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1;
        ListNode q = l2;
        ListNode cur = dummyHead;
        int carry = 0;
        while (p != null || q != null) {
            int x = 0;
            if (p != null) {
                x = p.val;
            }
            int y = 0;
            if (q != null) {
                y = q.val;
            }

            int sum = carry + x + y;
            carry = sum / 10;
            sum = sum % 10;
            cur.next = new ListNode(sum);

            if (p != null) {
                p = p.next;
            }
            if (q != null) {
                q = q.next;
            }
            cur = cur.next;
        }
        if (carry > 0) {
            cur.next = new ListNode(carry);
        }
        return dummyHead.next;
    }

}
```



### 树

#### [236.二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)

```java
class Solution {
    /*
    后序遍历
    lowestCommonAncestor(root, p, q) 抽象理解为在root中找p或q的祖先
    如果 left 为空不是 p或q的祖先，那就返回 right
    如果 right 为空不是 p或q的祖先，那就返回 left
    如果 left 不为空且 right 不为空，那就说明 root 肯定是 p q 的公共祖先
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        // p或q是根节点，那根节点就肯定是 p q 的公共祖先
        if (root == p || root == q) {
            return root;
        }
        // 在root.left中找p或q的祖先
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        // 在root.right中找p或q的祖先
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 如果 left 为空不是 p或q的祖先，那 right 肯定是 p q 的祖先
        if (left == null) {
            return right;
        }
        // 如果 right 为空不是 p或q的祖先，那 left 肯定是 p q 的祖先
        if (right == null) {
            return left;
        }
        // left 不为空且 right 不为空，那就说明 root 肯定是 p q 的公共祖先
        return root;
    }
}
```

#### [103.二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal)

```java
class Solution {
    /*
    广度优先搜索，通过flag控制在每层遍历时的方向
    queue.add(root)
    while(!queue.isEmpyt){
        int size = queue.size();
        for循环size次，每个size次为一层，根据flag确定插入方向
        for (int i=0; i<size; i++) {}
        res.add(linkedList),flag=!flag
    }
     */
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        boolean flag = true;
        queue.add(root);
        while (!queue.isEmpty()){
            // 通过size来一层一层的加入linkedList
            int size = queue.size();
            LinkedList<Integer> linkedList = new LinkedList<>();
            for (int i=0; i<size; i++) {
                TreeNode node = queue.remove();
                if (flag) {
                    linkedList.addLast(node.val);
                } else {
                    linkedList.addFirst(node.val);
                }

                if (node.left != null ) {
                    queue.add(node.left);
                }
                if (node.right != null ) {
                    queue.add(node.right);
                }
            }
            res.add(linkedList);
            flag = !flag;
        }
        return res;
    }
}
```



#### [199.二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view)

```java
class Solution {
    /*
     bfs 层次遍历
     每次进入while(!queue.isEmpty()),用一个size维护层次遍历
     每次层次遍历到(size-1)，这个就是要的右视图
     */
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i=0; i<size; i++) {
                TreeNode node = queue.poll();
                if (i == size-1) {
                    res.add(node.val);
                }
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        return res;
    }
}
```



#### [662.二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree)

```java
class Solution {
    /*
    层次遍历
    两个queue，一个存储节点，一个存储节点顺序值
    最右边顺序值 - 最左边 + 1 = 该层宽带
     */
    public int widthOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        LinkedList<TreeNode> queue = new LinkedList<>();
        LinkedList<Integer> levelQueue = new LinkedList<>();
        int res = 1;
        queue.add(root);
        levelQueue.add(1);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i=0; i<size; i++) {
                TreeNode node = queue.remove();
                int level = levelQueue.remove();
                if (node.left != null) {
                    queue.add(node.left);
                    levelQueue.add(2*level);
                }
                if (node.right != null) {
                    queue.add(node.right);
                    levelQueue.add(2*level +1);
                }
            }
            // 确保第二层有节点，计算才有意义
            if (levelQueue.size() > 0) {
                res = Math.max(res, levelQueue.getLast() - levelQueue.getFirst() + 1);
            }
        }
        return res;
    }
}
```

#### [543.二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree)

```java
class Solution {
    /*
    直径 ！= 左子树深度 + 右子树深度
    直径 = 最大的某个节点的左子树深度 + 右子树深度
    思路：后序遍历树的节点，维护一个全局变量max
         求得每个节点的直径，更新max
     */
    int max;
    public int diameterOfBinaryTree(TreeNode root) {
        traverse(root);
        return max;
    }
    // 返回树的深度
    int traverse(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = traverse(root.left); // 左子树的深度
        int right = traverse(root.right); // 右子树的深度
        // 直接访问全局变量
        max = Math.max(max, left + right);
        return 1 + Math.max(left, right);
    }
}
```

#### [129.求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers)

```java
class Solution {
    /*
    dfs 前序遍历
    维护一个tmp=0
    tmp = tmp*10 + root.val;
    然后往下一层传
    递归结束：
        root == null return 0
        root.left == null && root.right == null return  tmp
     */
    public int sumNumbers(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int tmp = 0;
        return  dfs(root, tmp);
    }
    private int dfs(TreeNode root, int tmp) {
        if (root == null) {
            return 0;
        }
        tmp = tmp*10 + root.val;
        if (root.left == null && root.right == null) {
            return tmp;
        }
        return dfs(root.left, tmp) + dfs(root.right, tmp);
    }
}
```



#### [105.根据前序和中序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)

```java
class Solution {
    /*
    递归法实现
    前序遍历数组的第一个数就是根节点，可以在中序遍历数组中找到把其分割开（左边是左子树中序遍历数组，右边是右子树中序遍历数组）
    然后前序遍历可以分成两个部分（根据中序遍历分割点），左边是左子树前序遍历数组，右边是右子树前序遍历数组
    然后分治+递归就可以得出答案
     */
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;;
        int inLen = inorder.length;
        return build(preorder, 0, preLen-1, inorder, 0, inLen-1);
    }
    TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        if (preStart > preEnd) {
            return null;
        }
        // root 节点对应的值就是前序遍历数组的第⼀个元素
        int rootVal = preorder[preStart];
        // rootVal 在中序遍历数组中的索引
        int index = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                index = i;
                break;
            }
        }
        int leftSize = index - inStart;
        // 先构造出当前根节点
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右⼦树
        root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1);
        root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd);
        return root;
    }
    /*
    迭代法
     */
    public TreeNode _buildTree(int[] preorder, int[] inorder) {
        if (preorder.length == 0) {
            return null;
        }
        Stack<TreeNode> roots = new Stack<TreeNode>();
        int pre = 0;
        int in = 0;
        //先序遍历第一个值作为根节点
        TreeNode curRoot = new TreeNode(preorder[pre]);
        TreeNode root = curRoot;
        roots.push(curRoot);
        pre++;
        //遍历前序遍历的数组
        while (pre < preorder.length) {
            //出现了当前节点的值和中序遍历数组的值相等，寻找是谁的右子树
            if (curRoot.val == inorder[in]) {
                //每次进行出栈，实现倒着遍历
                while (!roots.isEmpty() && roots.peek().val == inorder[in]) {
                    curRoot = roots.peek();
                    roots.pop();
                    in++;
                }
                //设为当前的右孩子
                curRoot.right = new TreeNode(preorder[pre]);
                //更新 curRoot
                curRoot = curRoot.right;
                roots.push(curRoot);
                pre++;
            } else {
                //否则的话就一直作为左子树
                curRoot.left = new TreeNode(preorder[pre]);
                curRoot = curRoot.left;
                roots.push(curRoot);
                pre++;
            }
        }
        return root;
    }
}
```



#### [106.根据中序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)

```java
class Solution {
    /*
    递归法实现
    与（从前序与中序遍历序列构造二叉树）相比
    后序遍历和前序遍历相反，根节点对应的值为 postorder 的最后⼀个元素。
     */
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int inLen = inorder.length;
        int postLen = postorder.length;;
        return build(inorder, 0, inLen-1, postorder, 0, postLen-1);
    }
    TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {
        if (inStart > inEnd) {
            return null;
        }
        // root 节点对应的值就是后序遍历数组的最后⼀个元素
        int rootVal = postorder[postEnd];
        // rootVal 在中序遍历数组中的索引
        int index = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                index = i;
                break;
            }
        }
        // 左⼦树的节点个数
        int leftSize = index - inStart;
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右⼦树
        root.left = build(inorder, inStart, index - 1, postorder, postStart, postStart + leftSize - 1);
        root.right = build(inorder, index + 1, inEnd, postorder, postStart + leftSize, postEnd - 1);
        return root;
    }

}
```



#### [889.根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal)

```java
class Solution {
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        if(pre==null || pre.length==0) {
            return null;
        }
        return dfs(pre,post);
    }
    /*
    用前序遍历的第一个元素创建出根节点
    用前序遍历的第二个元素x，去后序遍历中找对应的下标y，将y+1就能得到左子树的节点个数了
    将前序数组，后序数组拆分左右两部分
    递归的处理前序数组左边、后序数组右边
    递归的处理前序数组右边、后序数组右边
    返回根节点
     */
    private TreeNode dfs(int[] pre,int[] post) {
        if(pre==null || pre.length==0) {
            return null;
        }
        //数组长度为1时，直接返回即可
        if(pre.length==1) {
            return new TreeNode(pre[0]);
        }
        //根据前序数组的第一个元素，创建根节点
        TreeNode root = new TreeNode(pre[0]);
        int n = pre.length;
        for(int i=0;i<post.length;++i) {
            if(pre[1]==post[i]) {
                //根据前序数组第二个元素，确定后序数组左子树范围
                int left_count = i+1;
                //拆分前序和后序数组，分成四份
                int[] pre_left = Arrays.copyOfRange(pre,1,left_count+1);
                int[] pre_right = Arrays.copyOfRange(pre,left_count+1,n);
                int[] post_left = Arrays.copyOfRange(post,0,left_count);
                int[] post_right = Arrays.copyOfRange(post,left_count,n-1);
                //递归执行前序数组左边、后序数组左边
                root.left = dfs(pre_left,post_left);
                //递归执行前序数组右边、后序数组右边
                root.right = dfs(pre_right,post_right);
                break;
            }
        }
        //返回根节点
        return root;
    }
}
```

#### [112.路径总和](https://leetcode-cn.com/problems/path-sum)

```java
class Solution {
    /*
    路径总和II 简化版，没有回溯过程
    有一个满足结果直接 return true;
     */
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return dfs(root, targetSum);
    }
    private boolean dfs(TreeNode node, int sum) {
        if (node == null) {
            return false;
        }
        if (node.left == null && node.right == null && node.val == sum) {
            return true;
        }
        return  dfs(node.left, sum - node.val) || dfs(node.right, sum - node.val);
    }
}
```

#### [113.路径总和 II](https://leetcode-cn.com/problems/path-sum-ii)

```java
public class Solution {
    /*
    回溯解法，类似于组合求和
    dfs下去，往下层传 sum - node.val
    当到达叶子节点时，node.val == sum，满足条件
    list.add(node.val),res.add(new ArrayList<>(list)),list.removeLast(),return;
    同样套模板
     */
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if (root == null) {
            return res;
        }
        dfs(root, sum);
        return res;
    }
    private void dfs(TreeNode node, int sum) {
        if (node == null) {
            return;
        }
        if (node.left == null && node.right == null && node.val == sum) {
            list.add(node.val);
            res.add(new ArrayList<>(list));
            list.removeLast();
            return;
        }
        list.add(node.val);
        dfs(node.left, sum - node.val);
        dfs(node.right, sum - node.val);
        list.removeLast();
    }
}
```

#### [437.路径总和 III](https://leetcode-cn.com/problems/path-sum-iii) 

```java
class Solution {
    // key是前缀和, value是大小为key的前缀和出现的次数
    Map<Integer, Integer> preSumMap = new HashMap<>();
    int target;
    public int pathSum(TreeNode root, int sum) {
        target = sum;
        // 初始化前缀和为0的一条路径
        preSumMap.put(0, 1);
        // 前缀和的递归回溯思路
        return recursionPathSum(root, 0);
    }
    /*
     前缀和的递归回溯
     当前路径的前缀和 curSum = curSum + node.val
     如果之前路径存在前缀和 curSum - target
     说明存在路径的和为 target
     注：在回溯结束，回到上层时去除当前层，保证其不影响其他分支的结果
     */
    private int recursionPathSum(TreeNode node, int curSum) {
        if (node == null) {
            return 0;
        }

        int res = 0;
        // 当前路径上的前缀和
        curSum += node.val;

        // currSum-target相当于找路径的起点，当前点到起点的距离就是target
        res += preSumMap.getOrDefault(curSum - target, 0);
        // 更新路径上当前节点前缀和的个数
        preSumMap.put(curSum, preSumMap.getOrDefault(curSum, 0) + 1);

        // 进入下一层
        int left = recursionPathSum(node.left, curSum);
        int right = recursionPathSum(node.right, curSum);

        // 当我们把一个节点的前缀和信息更新到map里时，它应当只对其子节点们有效。
        preSumMap.put(curSum, preSumMap.get(curSum) - 1);

        // 结果是当前节点前缀树的个数加上左边满足的个数加右边满足的个数
        return res + left + right;
    }
}
```

#### [101.对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)

```java
class Solution {
    /*
    递归解法
    根节点左子树 ‘相当’ 根节点右子树
        根节点左子树的左子树值 = 根节点右子树的右子树值
        根节点左子树的右子树值 = 根节点右子树的左子树值
    递归出口：
        left == null && right == null true
        left == null || right == null false
        left.val != right.val false
     */
    public boolean _isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return dfs(root.left, root.right);
    }
    private boolean dfs(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        return dfs(left.left,right.right) && dfs(left.right, right.left);
    }
    // 迭代解法
    public boolean isSymmetric(TreeNode root) {
        if(root==null) {
            return true;
        }
        //用队列保存节点
        LinkedList<TreeNode> list = new LinkedList<>();
        //将根节点的左右孩子放到队列中
        list.add(root.left);
        list.add(root.right);
        while(list.size()>0) {
            //从队列中取出两个节点，再比较这两个节点
            TreeNode left = list.removeFirst();
            TreeNode right = list.removeFirst();
            //如果两个节点都为空就继续循环，两者有一个为空就返回false
            if(left==null && right==null) {
                continue;
            }
            if(left==null || right==null) {
                return false;
            }
            if(left.val!=right.val) {
                return false;
            }
            //将左节点的左孩子， 右节点的右孩子放入队列
            list.add(left.left);
            list.add(right.right);
            //将左节点的右孩子，右节点的左孩子放入队列
            .add(left.right);
            list.add(right.left);
        }
        return true;
    }
}
```

#### [958.二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree)

```java
class Solution {
    /*
            1
           / \
          2   3
             / \
            4   5
     BFS 解法，当左边出现null节点时，右边还出现节点那就是false
     */
    public boolean isCompleteTree(TreeNode root) {
        LinkedList<TreeNode> queue = new LinkedList<>();
        boolean reacheNull = false;
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.remove();
            if (node == null) {
                reacheNull = true;
            } else {
                if (reacheNull) {
                    return false;
                }
                // 入队时没判断是否为空
                // 所以是有可能从左边开始，把空节点加入队列的
                queue.add(node.left);
                queue.add(node.right);
            }
        }
        return true;
    }
}
```

#### [98.验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree)

```java
class Solution {
    /*
    二叉搜索树中序遍历是递增的
    根据这个特性来判断
    注：long pre = Long.MIN_VALUE;
     */
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST(root.left)) {
            return false;
        }
        if (root.val <= pre) {
            return false;
        }
        pre = root.val;

        return isValidBST(root.right);
    }
}
```



### LRU

#### [146.LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache)

```java
/*
 通过map来实现get缓存逻辑
 通过双向链表来实现“最近最少使用”逻辑
 通过变量size来维护双向链表的长度
 记录head和tail这两个头尾连接的空节点方便操作
 get(key) {
    node = map.get(key)
    node 存在:
        moveToHead(node)
        return node.val
    不存在:
        return -1
 }
 put(key) {
    key不存在:
        构建node
        addToHead(node)
        size溢出:
            removeTail()
            从map移除
    存在:
        更新map和DLinkedNode的值
        moveToHead(node)
 }
 实现需要的方法:
     moveToHead(node)
     addToHead(node)
     removeTail()
     removeNode(node)
 */
class LRUCache {
    // 构造双向链表
    class DLinkedNode {
        int key;
        int val;
        DLinkedNode pre;
        DLinkedNode next;
        public DLinkedNode(){}
        public DLinkedNode(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
    // 初始化capacity，size
    // 构造cacheMap，还要构造headNode，tailNode这两个头尾连接的空节点方便使用。
    public Map<Integer, DLinkedNode> cacheMap = new HashMap<>();
    public int capacity;
    public int size;
    public DLinkedNode headNode;
    public DLinkedNode tailNode;
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        headNode = new DLinkedNode();
        tailNode = new DLinkedNode();
        headNode.next = tailNode;
        tailNode.pre = headNode;
    }
    public int get(int key) {
        DLinkedNode node = cacheMap.get(key);
        if (node != null) {
            moveToHead(node);
            return node.val;
        } else {
            return -1;
        }
    }
    public void put(int key, int value) {
        DLinkedNode node = cacheMap.get(key);
        if (node == null) {
            DLinkedNode linkedNode = new DLinkedNode(key, value);
            cacheMap.put(key, linkedNode);
            addToHead(linkedNode);
            size++;
            if (size > capacity) {
                // 移除非空尾节点，需要把该非空尾节点返回出来，方便map移除
                DLinkedNode tailPre = removeTail();
                cacheMap.remove(tailPre.key);
                size--;
            }
        } else {
            cacheMap.put(key, node);
            moveToHead(node);
            node.val = value;
        }
    }
    // 重建前后节点的连接，
    public void removeNode(DLinkedNode node) {
        DLinkedNode preNode = node.pre;
        DLinkedNode nextNode = node.next;
        preNode.next = nextNode;
        nextNode.pre = preNode;
    }
    // 移除空的尾节点tail前一个节点就行
    public DLinkedNode removeTail() {
        DLinkedNode tailPre = tailNode.pre;
        removeNode(tailPre);
        return tailPre;
    }
    // 插入到空的头节点 head 和其下一个节点中间即可
    public void addToHead(DLinkedNode node) {
        DLinkedNode headNext = headNode.next;
        headNode.next = node;
        node.pre = headNode;
        node.next = headNext;
        headNext.pre = node;
    }
    // removeNode(node) -> addToHead
    public void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
}
```



### 栈

#### [42:接雨水](https://leetcode-cn.com/problems/trapping-rain-water)

```java
class Solution {
    /*
    单调栈解法
    https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/
    将数组索引操作进入单调栈
     */
    public int trap(int[] height) {
        int len = height.length;
        if (len == 0) {
            return 0;
        }
        Stack<Integer> stack = new Stack<>();
        int res = 0;
        for (int i=0; i<len; i++) {
            while (!stack.isEmpty() && height[stack.peek()] < height[i]) {
                int curIdx = stack.pop();
                // 如果栈顶元素一直相等，那么全都pop出去，只留前一个（左边界）。
                while (!stack.isEmpty() && height[curIdx] == height[stack.peek()]) {
                    stack.pop();
                }
                if (!stack.isEmpty()) {
                    int stackTop = stack.peek();
                    // stackTop此时指向的是此次接住的雨水的左边界的位置。右边界是当前的柱体，即i。
                    // Math.min(height[stackTop], height[i]) 是左右柱子高度的min，减去height[curIdx]就是雨水的高度。
                    // i - stackTop - 1 是雨水的宽度。
                    res += (Math.min(height[stackTop], height[i]) - height[curIdx]) * (i - stackTop -1);
                }
            }
            stack.add(i);
        }
        return res;
    }
}
```

#### [402.移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits)

```java
class Solution {
    /*
    单调栈解法
    当num[i]>num[i+1]，删掉，总共删除 K 次
     */
    public String removeKdigits(String num, int k) {
        LinkedList<Character> stack = new LinkedList<>();
        // 当num[i]>num[i+1]，删掉，总共删除 K 次
        for(char c : num.toCharArray()){
            while(k > 0 && !stack.isEmpty() && c < stack.peek()){
                stack.pop();
                k--;
            }
            // 避免0入空栈：当前的字符不是"0"，或栈非空才入栈
            if( c != '0' || !stack.isEmpty()){
                stack.push(c);
            }
        }
        // 没删够还要继续删
        while( k > 0 && !stack.isEmpty()){
            stack.pop();
            k--;
        }
        StringBuilder buffer = new StringBuilder();
        while(!stack.isEmpty()){
            buffer.append(stack.pop());
        }
        buffer.reverse();
        return buffer.length() == 0 ? "0" : buffer.toString();
    }
}
```



#### [155.最小栈](https://leetcode-cn.com/problems/min-stack)

```java
class _MinStack {
    Stack<Integer> stack = new Stack<>();
    Stack<Integer> minStack = new Stack<>();
    public _MinStack() {
    }
    public void push(int x) {
        stack.push(x);
        if (!minStack.isEmpty()) {
            int top = minStack.peek();
            //小于的时候才入栈
            if (x <= top) {
                minStack.push(x);
            }
        }else{
            minStack.push(x);
        }
    }
    public void pop() {
        int pop = stack.pop();
        int top = minStack.peek();
        //等于的时候再出栈
        if (pop == top) {
            minStack.pop();
        }

    }
    public int top() {
        return stack.peek();
    }
    public int getMin() {
        return minStack.peek();
    }
}
```



#### [20.有效的括号](https://leetcode-cn.com/problems/valid-parentheses)

```java
class Solution {
    /*
    辅助栈解法
    遍历字符串，遇到左边，入栈右边
    遇到右边，出栈字节，对比右边
    栈为空 或者 栈顶不等右边 就是错
    最后栈为空就真
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        char[] chars = s.toCharArray();
        for (char c : chars) {
            if (c == '(') {
                stack.push(')');
            } else if (c == '{') {
                stack.push('}');
            } else if (c == '[') {
                stack.push(']');
            } else if(stack.isEmpty() || stack.pop()!=c) {
                return false;
            }
        }
        return stack.empty();
    }
}
```



### 数组

#### [1.两数之和](https://leetcode-cn.com/problems/two-sum)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i=0; i< nums.length; i++) {
            if (map.containsKey(target-nums[i])) {
                return new int[]{i, map.get(target-nums[i])};
            } else {
                map.put(nums[i], i);
            }
        }
        return null;
    }
}
```

#### [31.下一个排列](https://leetcode-cn.com/problems/next-permutation)

```java
class Solution {
    /*
    123465
    654321
     */
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if (len <= 1) {
            return;
        }
        for (int i = len-1; i>0; i--) {
            //从后往前找，找到最右边的升序
            if (nums[i] > nums[i-1]) {
                // 将最右边第一个比nums[i-1]大的数与nums[i-1]交换
                // 这个数肯定是右边最小的数，这个数最大就是nums[i]
                for (int j=len-1; j>=i; j--) {
                    if (nums[j] > nums[i-1]) {
                        swap(nums, i-1, j);
                        // 需要跳出for循环
                        break;
                    }
                }
                Arrays.sort(nums, i, len);
                return;
            }
        }
        Arrays.sort(nums);
    }
    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```



#### [41.缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive)

```java
/*
原地哈希
使用座位交换法
      根据思路② 可知，缺失的第一个整数是 [1, len + 1] 之间，
      那么我们可以遍历数组，然后将对应的数据填充到对应的位置上去，比如 1 就填充到 nums[0] 的位置， 2 就填充到 nums[1]
      如果填充过程中， nums[i] < 1 && nums[i] > len，那么直接舍弃
      填充完成，我们再遍历一次数组，如果对应的 nums[i] != i + 1，那么这个 i + 1 就是缺失的第一个正数

      比如 nums = [7, 8, 9, 10, 11], len = 5
      我们发现数组中的元素都无法进行填充，直接舍弃跳过，
      那么最终遍历数组的时候，我们发现 nums[0] != 0 + 1，即第一个缺失的是 1 

      比如 nums = [3, 1, 2], len = 3
      填充过后，我们发现最终数组变成了 [1, 2, 3]，每个元素都对应了自己的位置，那么第一个缺失的就是 len + 1 == 4
*/
class Solution {
    public int firstMissingPositive(int[] nums) {

        int len = nums.length;
        for(int i = 0; i < len; i++){
       /*
       只有在 nums[i] 是 [1, len] 之间的数，并且不在自己应该呆的位置， nums[i] != i + 1 ，
        并且 它应该呆的位置没有被同伴占有（即存在重复值占有）	nums[nums[i] - 1] != nums[i] 的时候才进行交换
        	
        为什么使用 while ？ 因为交换后，原本 i 位置的 nums[i] 已经交换到了别的地方，
        交换后到这里的新值不一定是适合这个位置的，因此需要重新进行判断交换
        如果使用 if，那么进行一次交换后，i 就会 +1 进入下一个循环，那么交换过来的新值就没有去找到它该有的位置
         比如 nums = [3, 4, -1, 1] 当 3 进行交换后， nums 变成 [-1，4，3，1]，
         此时 i == 0，如果使用 if ，那么会进入下一个循环， 这个 -1 就没有进行处理
        */
            while(nums[i] > 0 && nums[i] <= len && nums[i] != i + 1 && nums[nums[i] - 1] != nums[i]){
                swap(nums, nums[i] - 1, i);
            }
        }
        for(int i = 0; i < len; i++){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        return len + 1;
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



#### [54.螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix)

```java
class Solution {
    /*
    按照右下左上的顺序移动
    每次移动到了边界就重新设定边界
    边界超出就break
     */
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        // 数组为空直接返回
        if (matrix.length == 0) {
            return res;
        }
        // 设定上下左右四个边界
        int up = 0;
        int down = matrix.length-1;
        int left = 0;
        int right = matrix[0].length-1;
        while (true) {
            // 往右移动，当到最右边时停下来
            for (int col=left ; col<=right; col++) {
                res.add(matrix[up][col]);
            }
            // 重新设定上边界
            up++;
            // 若上边界超过下边界，跳出
            if (up > down) {
                break;
            }
            // 往下移
            for (int row=up ; row<=down; row++) {
                res.add(matrix[row][right]);
            }
            right--;
            if (right < left) {
                break;
            }
            // 往左移
            for (int col=right ; col>=left; col--) {
                res.add(matrix[down][col]);
            }
            down--;
            if (down < up) {
                break;
            }
            // 往上移
            for (int row=down ; row>=up; row--) {
                res.add(matrix[row][left]);
            }
            left++;
            if (left > right) {
                break;
            }
        }
        return res;
    }
}
```



#### [48.旋转图像](https://leetcode-cn.com/problems/rotate-image)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
```



#### [56.合并区间](https://leetcode-cn.com/problems/merge-intervals)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 先按照区间起始位置排序
        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
        // 遍历区间
        int[][] res = new int[intervals.length][2];
        int index = -1;
        for (int[] interval: intervals) {
            // 如果结果数组是空的，或者当前区间的起始位置 > 结果数组中最后区间的终止位置，
            // 则不合并，直接将当前区间加入结果数组。
            if (index == -1 || interval[0] > res[index][1]) {
                index++;
                res[index] = interval;
            } else {
                // 反之将当前区间合并至结果数组的最后区间
                res[index][1] = Math.max(res[index][1], interval[1]);
            }
        }
        return Arrays.copyOf(res, index + 1);
    }
}
```



#### [560.和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

```java
public class Solution {
    /*
    前缀和解法
    1 2 3 4 5
    1 的前缀和是1,3的前缀和是6
    6-1=5,1到3（不包括1）的路径就是 子数组和为5
    注意：前缀和数组偏移量为 +1
     */
    public int subarraySum(int[] nums, int k) {
        int len = nums.length;
        int count = 0;
        if (len == 0) {
            return count;
        }
        // 构建前缀和数组
        int[] preSum = new int[len+1];
        for (int i=0; i<len; i++) {
            preSum[i+1] = preSum[i] + nums[i];
        }
        // 寻找路径
        for (int left = 0; left < len; left++) {
            for (int right = left; right < len; right++) {
                if (preSum[right+1] - preSum[left] == k) {
                    count++;
                }
            }
        }
        return count;
    }
    // 哈希表优化前缀和
    public int _subarraySum(int[] nums, int k) {
        // key：前缀和，value：key 对应的前缀和的个数
        Map<Integer, Integer> preSumFreq = new HashMap<>();
        // 对于下标为 0 的元素，前缀和为 0，个数为 1
        preSumFreq.put(0, 1);
        int preSum = 0;
        int count = 0;
        for (int num : nums) {
            preSum += num;
            // 先获得前缀和为 preSum - k 的个数，加到计数变量里
            if (preSumFreq.containsKey(preSum - k)) {
                count += preSumFreq.get(preSum - k);
            }
            // 然后维护 preSumFreq 的定义
            preSumFreq.put(preSum, preSumFreq.getOrDefault(preSum, 0) + 1);
        }
        return count;
    }
}
```

#### [88.合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array)

```java
class Solution {
    /*
    从后往前依次比较两个数组，将大的数放 nums1
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m - 1, index2 = n - 1;
        int indexMerge = m + n - 1;
        while (index1 >= 0 || index2 >= 0) {
            if (index1 < 0) {
                nums1[indexMerge--] = nums2[index2--];
            }
            else if (index2 < 0) {
                nums1[indexMerge--] = nums1[index1--];
            }
            else if (nums1[index1] > nums2[index2]) {
                nums1[indexMerge--] = nums1[index1--];
            }
            else {
                nums1[indexMerge--] = nums2[index2--];
            }
        }
    }
}
```

### 字符串

#### [415.字符串相加](https://leetcode-cn.com/problems/add-strings)

```java
class Solution {
    /*
    两个num数组，从最右侧开始，一个一个的取出数（n1,n2）来加
    一个加到头了，就取0
    维护一个 carry = tmp / 10，表示进位
    int tmp = n1 + n2 + carry;
    StringBuilder res
    res.append(tmp % 10);
    注：最后的进位1需要考虑
    res.reverse()
     */
    public String addStrings(String num1, String num2) {
        StringBuilder res = new StringBuilder("");
        int i = num1.length() - 1;
        int j = num2.length() - 1;
        int carry = 0;
        while(i >= 0 || j >= 0){
            int n1;
            if (i >= 0) {
                n1 = num1.charAt(i) - '0';
            } else {
                n1 = 0;
            }
            int n2;
            if (j >= 0) {
                n2 = num2.charAt(j) - '0';
            } else {
                n2 = 0;
            }
            int tmp = n1 + n2 + carry;
            carry = tmp / 10;
            res.append(tmp % 10);
            i--;
            j--;
        }
        if(carry == 1) {
            res.append(1);
        }
        return res.reverse().toString();
    }
}
```



## 算法

### 动态规划

#### [72.编辑距离](https://leetcode-cn.com/problems/edit-distance)

```java
class Solution {
    /*
    状态定义：dp[i][j]=x word1前i个字符的字符串变为word2前j个字符的字符串最少x步
    初始状态：
        word1前i个字符的字符串变为空串至少需要i步：dp[i][0]=i
        空串变为word2前j个字符的字符串至少需要j步：dp[0][j]=j
    做选择：
        删除：dp[i][j]=dp[i-1][j]+1      abcd,abc
        插入：dp[i][j]=dp[i][j-1]+1      abc,abcd
        替换：dp[i][j]=dp[i-1][j-1]+1    abcd,abce
    状态转移方程：
        不一样：dp[i][j]=min(删,改，插)
        一样：dp[i][j] = dp[i - 1][j - 1]
     */
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        // word1前i个字符的字符串变为word2前j个字符的字符串最少需要的步数
        int[][] dp = new int[n+1][m+1];
        // base case
        for (int i=1;i<n+1;i++){
            dp[i][0]=i;
        }
        for (int j=1;j<m+1;j++){
            dp[0][j]=j;
        }
        for (int i=1;i<n+1;i++){
            for (int j=1;j<m+1;j++){
                if (word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else{
                    dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1);
                }
            }
        }
        return dp[n][m];
    }
    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

#### [322.零钱兑换](https://leetcode-cn.com/problems/coin-change)

```java
class Solution {
    /*
    状态：dp[n]=x,凑出n金额，最少需要x枚金币
    初始状态：dp[0]=0

    选择：要不要第i枚金币

    递推关系: dp[11] = min (dp[10] + 1, dp[9] + 1, dp[6] + 1, , , , , , ,)

    return: dp[amount]
    */
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp, amount+1);
        // dp[amount] 最大不可能超过 amount，所以 amount + 1 就是一个无意义的数。
        // 所以将 dp 数组的所有元素都初始化为 amount + 1
        dp[0]=0;
        for (int i=1;i<=amount;i++){
            for (int coin : coins) {
                if (coin <= i) {
                    // dp[11] = min (dp[10] + 1, dp[9] + 1, dp[6] + 1，............)
                    // 所以遍历 coins ，dp[i] = Math.min(dp[i], dp[i - coin] + 1)
                    // min 中的dp[i] 记录的遍历过程中的最小值
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        // 哪怕有一个元素是大于 amount + 1 的最终都会被最小化为 amount + 1，
        // 所以这里使用 dp[amount] > amount 还是 dp[amount] == amount + 1 没有区别。
        if (dp[amount] == amount + 1) {
            return -1;
        } else {
            return dp[amount];
        }
    }
}
```

#### [518.零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2)

```java
class Solution {
    /*
    状态定义：若只使用 coins 中的前 i 个硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法。
    初始状态：dp[0][..] = 0， dp[..][0] = 1

    选择：
        不把这第 i 个物品装入背包：dp[i][j] = dp[i-1][j]
        把这第 i 个物品装入了背包：dp[i][j] = dp[i][j-coins[i-1]]

    状态转移方程：
        if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i-1]];
     */
    int _change(int amount, int[] coins) {
        int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++)
                if (j - coins[i-1] >= 0) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
        }
        return dp[n][amount];
    }
    /*
    状态定义：dp[i] 表示金额之和等于 x 的硬币组合数
    初始状态：dp[0] = 1
    状态转移方程：dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + ...........

    注意！爬楼梯泛化解法相当于排列，顺序不同表示不同的解法，本题解法类似于组合，顺序不同也表示相同的解法
    本题将 j(coin) 放在外层先遍历，先花完一种钱，再花下一种
    不允许在后面的硬币层次使用前面的硬币，这样就避免重复了
     */
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = 1; i <= amount; i++) {
                if (i >= coin) {
                    dp[i] += dp[i - coin];
                }
            }
        }
        return dp[amount];
    }
}
```

#### [70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)

```java
class Solution {
    /*
    从第0级开始爬，不动，1种方法
    从第1级开始爬，上一阶，1种方法
     */
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        int[] steps = new int[]{1,2};
//            for (int i=2; i<=n; i++) {
//                dp[i] = dp[i-1] + dp[i-2];
//            }
        for (int i=1; i<=n; i++) {
            for (int j=0; j<steps.length; j++) {
                int step = steps[j];
                if (i >= step) {
                    dp[i] = dp[i] + dp[i-step];
                }
            }
        }
        return dp[n];
        /*
        用这个是不可以的，这种把步长的顺序固定住了，相当于求组合数，本题求排列数
        （212 和 122在排列里面是不同的，在组合里面是相同的）
        * */
//            for (int j=0; j<steps.length; j++) {
//                int step = steps[j];
//                for (int i=2; i<=n; i++) {
//                    if (i >= step) {
//                        dp[i]+=dp[i-step];
//                    }
//                }
//            }
    }
    /*
    泛化，可以走任意步时的解法
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + ...........
     */
    public int _climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        for (int i=1; i<=n; i++) {
            for (int j=0; j<=i; j++) {
                dp[i] = dp[i] + dp[i-j];
            }
        }
        return dp[n];
    }
}
```



#### [32.最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses)

```java
class Solution {
    /*
    dp[i] 是以 s[i] 为字符结尾的最长有效子字符串的长度。
    s[i] == '(':
        这时，s[i] 无法和其之前的元素组成有效的括号对，dp[i] = 0
    s[i] == ')':
        s[i - 1] == '('
            即 s[i] 和 s[i - 1] 组成一对有效括号，那么有：dp[i] = dp[i - 2] + 2
            注意，如果是前两个，即 i<2，那么 dp[i] = 2
        s[i - 1] == ')'
            这种情况下，判断前面是否有和s[i]组成有效括号对的字符，即形如((....))。
            即跨过 dp[i - 1] 判断前一个字符：i - dp[i - 1] - 1。
            注意，需要dp[i - 1]是有效字符串才用判断前面的，即dp[i - 1]>0
            s[i - dp[i - 1] - 1] == '(':
                有效括号长度新增长度2：dp[i] = dp[i - 1] + 2
                    注意，i - dp[i - 1] - 1 和 i 组成了有效括号对，这将是一段独立的有效括号序列 ((....))
                    如果之前的子序列是 (...)(...) 这种序列，那么当前位置的最长有效括号长度还需要加上这一段。所以：
                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2
    */
    public int longestValidParentheses(String s) {
        int n = s.length();
        int[] dp = new int[n];//dp是以i处括号结尾的有效括号长度
        int max_len = 0;
        //i从1开始，一个是单括号无效，另一个是防i - 1索引越界
        for(int i = 1; i < n; i++) {
            //遇见右括号才开始判断
            if(s.charAt(i) == ')') {
                //上一个是左括号
                if(s.charAt(i - 1) == '(') {
                    if(i < 2) { //开头处
                        dp[i] = 2;
                    } else { //非开头处
                        dp[i] = dp[i - 2] + 2;
                    }
                }
                //上一个是右括号
                else {
                    //pre_left为i处右括号对应左括号下标，推导：(i-1)-dp[i-1]+1 - 1
                    int pre_left = i - dp[i - 1] - 1;
                    //dp[i - 1]是有效字符串 && s[]i - dp[i - 1] - 1 存在
                    if(dp[i - 1] > 0 && pre_left >= 0 && s.charAt(pre_left) == '(') {//左括号存在且为左括号（滑稽）
                        dp[i] = dp[i - 1] + 2;
                        //左括号前还可能存在有效括号
                        if(pre_left - 1 > 0) {
                            dp[i] = dp[i] + dp[pre_left - 1];
                        }
                    }
                }
            }
            max_len = Math.max(max_len, dp[i]);
        }
        return max_len;
    }
}
```

#### [10.正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching)

```java
class Solution {
    /*
    dp解法
    状态定义：dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
    初始状态：s为空，p为空，dp[0][0] = true
            p为空，s不为空，必为false，
            s为空，p不为空，由于*可以匹配0个字符，所以 dp[0][j] = dp[0][j - 2]
    填格子做选择：
        for (int i = 1; i <= cs.length; i++) {
            for (int j = 1; j <= cp.length; j++) {
                再从右往左拆解成子问题
     */
    public boolean isMatch(String s, String p) {
        char[] cs = s.toCharArray();
        char[] cp = p.toCharArray();
        // dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
        // dp[i][j] 对应的 cs[i-1]，cp[j-1]
        boolean[][] dp = new boolean[cs.length + 1][cp.length + 1];
        // base case
        // s为空，p为空，能匹配上
        // p为空，s不为空，必为false
        // s为空，p不为空，由于*可以匹配0个字符，所以有可能为true
        dp[0][0] = true;
        for (int j = 1; j <= cp.length; j++) {
            if (cp[j - 1] == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }
        // 填格子做选择
        for (int i = 1; i <= cs.length; i++) {
            for (int j = 1; j <= cp.length; j++) {
                // 文本串和模式串末位字符能匹配上
                if (cs[i - 1] == cp[j - 1] || cp[j - 1] == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                // 模式串末位是*
                else if (cp[j - 1] == '*') {
                    // 模式串*的前一个字符能够跟文本串的末位匹配上
                    if (cs[i - 1] == cp[j - 2] || cp[j - 2] == '.') {
                        // *匹配0次，  s(0,i-1),p(0,j-3)
                        // *匹配1次，  s(0,i-2),p(0,j-3)
                        // *匹配>=2次，s往左一格继续判断，s(0,i-2),p(0,j-1)
                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
                    }
                    // 模式串*的前一个字符不能够跟文本串的末位匹配
                    // *干掉cp[j - 2]
                    else {
                        dp[i][j] = dp[i][j - 2];
                    }
                }
            }
        }
        return dp[cs.length][cp.length];
    }
}
```

#### [53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

```java
class Solution {
    /*
    dp[i]：以num[i]为结尾的最大子数组和
    状态转移方程：dp[i] = dp[i-1] + nums[i]，当 dp[i-1] <= 0，前面的直接不要了 dp[i] = nums[i];
     */
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
        dp[0] = nums[0];
        int max = dp[0];
        for (int i=1; i<len; i++) {
            if (dp[i-1] > 0) {
                dp[i] = dp[i-1] + nums[i];
            } else {
                dp[i] = nums[i];
            }
            max = Math.max(dp[i], max);
        }
        return max;
    }
}
```



#### [300.最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)

```java
class Solution {
    /*
    状态定义：dp[i] 的值代表 nums 以 nums[i] 结尾的最长子序列长度。
    转移方程：设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，做以下判断：
        if(nums[i]>nums[j]):
            nums[i] 可以接在nums[j] 之后,此情况下最长上升子序列长度为 dp[j] + 1。
        else:
            nums[i] 无法接在 nums[j] 之后，此情况上升子序列不成立，跳过。
    初始状态：dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
    返回值：dp 列表最大值
    */
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return len;
        }
        int[] dp = new int[len];
        Arrays.fill(dp,1);
        int res = 0;
        int pos = 0;
        for (int i=0; i<len; i++) {
            for (int j=0; j<i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j]+1);
                }
            }
            if (dp[i] >= res) {
                res = dp[i];
                pos = i;
            }
        }

        int posdp = res;
        List<Integer> list = new ArrayList<>();
        list.add(nums[pos]);
        for (int i=pos-1; i>=1; i--) {
            if (dp[i] == posdp-1) {
                list.add(nums[i]);
                posdp = dp[i];
            }
        }
        System.out.println(list);

        return res;
    }

    // 纸牌算法，二分
    public int _lengthOfLIS(int[] nums) {
        int[] top = new int[nums.length];
        // 牌堆数初始化为 0
        int piles = 0;
        for (int i = 0; i < nums.length; i++) {
            // 要处理的扑克牌
            int poker = nums[i];

            /***** 搜索左侧边界的二分查找 *****/
            int left = 0, right = piles;
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] > poker) {
                    right = mid;
                } else if (top[mid] < poker) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            /*********************************/

            // 没找到合适的牌堆，新建一堆
            if (left == piles) piles++;
            // 把这张牌放到牌堆顶
            top[left] = poker;
        }
        // 牌堆数就是 LIS 长度
        return piles;
    }
}
```



#### [128.最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence)

```java
class Solution {
    /*
    部分动态规划思想 + 哈希表
    比如 num是5，此时1234 678都在哈希表中
    此时哈希表中，1的位置和4存的值都是4，6和8存的值都是3
    所以5进来之后，发现左边有4个连续的，右边有3个连续的，加上自己一个，那么组成一个大连续的
    4+1+3 = 8
    所以要更新当前最长连续串的端点，也就是1的位置（5-4），8的位置（5+3），更新长度为8
    只需要端点存值就行，因为端点中的值在遍历的时候如果在哈希表中就会略过
     */
    public int longestConsecutive(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int res = 0;
        for (Integer n : nums) {
            if (map.containsKey(n)) {
                continue;
            }
            // 获取当前数的左边连续长度,没有的话就更新为0
            int left = map.getOrDefault(n - 1, 0);
            // 同理获取右边的数
            int right = map.getOrDefault(n + 1, 0);
            // 当前数左右连续长度
            int len = left + 1 + right;
            // 当前数存入map，仅代表当前数字出现过
            map.put(n, -1);
            //更新两端值，当两端没出现时，更新的就是自己的值
            map.put(n - left, len);
            map.put(n + right, len);

            res = Math.max(res, len);
        }
        return res;
    }
}
```



#### [5.最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)

```java
public class Solution {
    /*
    动态规划
    dp[i,j]=true/false：以i,j为首尾的字符串是否为回文子串
    dp[i,i] = true
    状态转移方程：
        charArray[i] == charArray[j]
            dp[i][j] = dp[i+1][j-1]
            注：当s[i,s] 去掉头尾两个字符后的区间长度小于2，dp[i][j]肯定是true，即(i+1) - (j-1) + 1 < 2
     */
    public String _longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        boolean[][] dp = new boolean[len][len];
        char[] charArray = s.toCharArray();
        int max = 1;
        int begin = 0;
        //单字符，i=j时, charArray[i] == charArray[j]
        for (int j=0; j<len; j++) {
            for (int i=0; i<=j; i++) {
                if (charArray[i] == charArray[j]) {
                    // s[i,s] 去掉头尾两个字符，s[i+1, j-1]的区间长度小于2，dp[i][j]肯定是true
                    // (i+1) - (j-1) + 1 < 2;
                    if (j-i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if (dp[i][j] && max < j-i+1) {
                    max = j-i+1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin+max);
    }
    // 中心扩散法
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        int left;
        int right;
        int begin = 0;
        int max = 1;
        for (int i = 0; i < len; i++) {
            left = i;
            right = i;
            // 中心可能为多个一样的字符
            // 往左寻找中心
            while (left > 0 && s.charAt(left-1) == s.charAt(i)) {
                left--;
            }
            // 往右寻找中心
            while (right < len-1 && s.charAt(right+1) == s.charAt(i)) {
                right++;
            }
            // 进行中心扩散
            while (left > 0 && right < len-1 && s.charAt(right+1) == s.charAt(left-1)) {
                left--;
                right++;
            }
            if (right-left+1 > max) {
                max = right-left+1;
                begin = left;
            }
        }
        return s.substring(begin, begin + max);
    }
}
```



#### 背包问题

##### 01背包

问：给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

```java
/* 
状态定义：dp[i][w]，对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
初始状态：dp[0][..] = dp[..][0] = 0

选择：
	没有把这第 i 个物品装入背包：dp[i][w] = dp[i-1][w]
	把这第 i 个物品装入了背包：dp[i][w] = dp[i-1][w - wt[i-1]] + val[i-1]

状态转移方程：
    if (w - wt[i-1] < 0) {
    	// 这种情况下只能选择不装入背包
        dp[i][w] = dp[i - 1][w];
        } else {
        // 装入或者不装入背包，择优
        dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], dp[i - 1][w]);
     }

*/
```

```java
int knapsack(int W, int N, int[] wt, int[] val) {
    // base case 已初始化
    int[][] dp = new dp[N+1][W+1];
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i-1] < 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], dp[i - 1][w]);
            }
        }
    }
    return dp[N][W];
}
```



##### 完全背包

###### [518.零钱兑换II](https://leetcode-cn.com/problems/coin-change-2)

```java
/*
转换成背包问题：有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？

状态定义：若只使用 coins 中的前 i 个硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法。
初始状态：dp[0][..] = 0， dp[..][0] = 1

选择：
	不把这第 i 个物品装入背包：dp[i][j] = dp[i-1][j]
	把这第 i 个物品装入了背包：dp[i][j] = dp[i][j-coins[i-1]]
	
状态转移方程：
	if (j - coins[i-1] >= 0)
            dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i-1]];

*/
```

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = int[n + 1][amount + 1];
    // base case
    for (int i = 0; i <= n; i++) 
        dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++)
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]];
            else：
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}

```



#### 股票问题

```java
// base case：
dp[-1][...][0] = dp[...][0][0] = 0            // i = -1 意味着还没有开始，这时候的利润是0。 k=0 意味着根本不允许交易，这时候利润是0。
dp[-1][...][1] = dp[...][0][1] = -infinity    // 还没开始的时候，是不可能持有股票的。不允许交易的情况下，是不可能持有股票的。因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值。 
// 状态转移⽅程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])     // ( 今天选择 rest, 今天选择 sell )
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])   // ( 今天选择 rest, 今天选择 buy  ) 
```

##### [121.买卖股票的最佳时机（k = 1）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

```java
// k = 1
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])
// 解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。
// 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
// 可以进⾏进⼀步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

```java
// 原始版本
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case
            // 根据状态转移⽅程可得：
            // dp[i][0]
            // = max(dp[-1][0], dp[-1][1] + prices[i])
            // = max(0, -infinity + prices[i]) = 0
            dp[i][0] = 0;
            // 根据状态转移⽅程可得：
            // dp[i][1]
            // = max(dp[-1][1], dp[-1][0] - prices[i])
            // = max(-infinity, 0 - prices[i])
            // = -prices[i]
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        // dp[i][1] = max(dp[i-1][1], -prices[i])
        dp_i_1 = Math.max(dp_i_1, -prices[i]);
    }
    return dp_i_0;
}
```

##### [122.买卖股票的最佳时机 II（k = +infinity）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)

```java
// k = +infinity 
// 如果 k 为正⽆穷，那么就可以认为 k 和 k - 1 是⼀样的。可以这样改写框架：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
// 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
```

```java
// 原始版本
int maxProfit_k_inf(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_k_inf(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
    }
    return dp_i_0;
}
```

##### [309.最佳买卖股票时机含冷冻期（k = +infinity with cooldown）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```java
// k = +infinity with cooldown
// 参考K为正无穷
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
// 第 i 天选择 buy 的时候，要从 i-2 的状态转移，⽽不是 i-1 。
```

```java
// 原始版本
int maxProfit_with_cool(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case 1
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        if (i - 2 == -1) {
            // base case 2
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            // i - 2 ⼩于 0 时根据状态转移⽅程推出对应 base case
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
            // dp[i][1]
            // = max(dp[i-1][1], dp[-1][0] - prices[i])
            // = max(dp[i-1][1], 0 - prices[i])
            // = max(dp[i-1][1], -prices[i])
            continue;
        }
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_with_cool(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    int dp_pre_0 = 0; // 代表 dp[i-2][0]
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
        dp_pre_0 = temp;
    }
    return dp_i_0;
}
```

##### [714.买卖股票的最佳时机含手续费（k = +infinity with fee）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

```java
// k = +infinity with fee
// 每次交易要⽀付⼿续费，只要把⼿续费从利润中减去即可。改写⽅程：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
// 相当于买⼊股票的价格升⾼了。
// 在第⼀个式⼦⾥减也是⼀样的，相当于卖出股票的价格减⼩了。
```

```java
// 原始版本
int maxProfit_with_fee(int[] prices, int fee) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i] - fee;
            // dp[i][1]
            // = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
            // = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
            // = max(-inf, 0 - prices[i] - fee)
            // = -prices[i] - fee
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
    }
    return dp[n - 1][0];
}
// 空间复杂度优化版本
int maxProfit_with_fee(int[] prices, int fee) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
    }
    return dp_i_0;
}
```

##### [123.买卖股票的最佳时机III（k = 2）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)

```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

```java
// 原始版本
int maxProfit_k_2(int[] prices) {
    int max_k = 2, n = prices.length;
    int[][][] dp = new int[n][max_k + 1][2];
    for (int i = 0; i < n; i++) {
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // 处理 base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
        }
    }
    // 穷举了 n × max_k × 2 个状态，正确。
    return dp[n - 1][max_k][0];
}
// 状态转移⽅程：
// dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
// dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
// dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
// dp[i][1][1] = max(dp[i-1][1][1], -prices[i])
// 空间复杂度优化版本
int maxProfit_k_2(int[] prices) {
    // base case
    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
    for (int price : prices) {
        dp_i20 = Math.max(dp_i20, dp_i21 + price);
        dp_i21 = Math.max(dp_i21, dp_i10 - price);
        dp_i10 = Math.max(dp_i10, dp_i11 + price);
        dp_i11 = Math.max(dp_i11, -price);
    }
    return dp_i20;
}
```

##### [188.买卖股票的最佳时机 IV（k = any integer）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)

```java
int maxProfit_k_any(int max_k, int[] prices) {
    int n = prices.length;
    if (n <= 0) {
        return 0;
    }
    if (max_k > n / 2) {
        // 交易次数 k 没有限制的情况
        return maxProfit_k_inf(prices);
    }
    // base case：
    // dp[-1][...][0] = dp[...][0][0] = 0
    // dp[-1][...][1] = dp[...][0][1] = -infinity
    int[][][] dp = new int[n][max_k + 1][2];
    // k = 0 时的 base case
    for (int i = 0; i < n; i++) {
        dp[i][0][1] = Integer.MIN_VALUE;
        dp[i][0][0] = 0;
    }
    for (int i = 0; i < n; i++)
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // 处理 i = -1 时的 base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
        }
    return dp[n - 1][max_k][0];
}
```



#### 区间dp

##### [221.最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```java
class Solution {
    // dp思路:相邻三个矩形边长的最小值+1
    // 若某格子值为 1，则以此为右下角的正方形的、最大边长为：上面的正方形、左面的正方形或左上的正方形中，最小的那个，再加上此格。
    public int maximalSquare(char[][] matrix) {
        int maxSide = 0;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return maxSide;
        }
        int rows = matrix.length;
        int columns = matrix[0].length;

        int[][] dp = new int[rows][columns];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        // base case
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }
        return maxSide * maxSide;
    }
}
```



### n指针

#### [15.三数之和](https://leetcode-cn.com/problems/3sum)

```java
class Solution {
    /*
    三指针解法
    i=0,j=i+1,k=nums.len
     for (int i=0; i<length-2; i++){
        int temp = nums[i] + nums[j] + nums[k];
        temp > 0 k--
        temp < 0 j++
        temp = 0 res.add
            // 去重操作
            while(j<k && nums[j]=nums[j+1])
                j++
            while(j<k && nums[k]=nums[k-1])
                k--
     }
     */
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums.length<3) {
            return res;
        }
        Arrays.sort(nums);
        int length = nums.length;
        for (int i=0; i<length-2; i++){
            if (nums[i] > 0) {
                break;
            }
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int j = i + 1;
            int k = length-1;
            while (j<k) {
                int temp = nums[i] + nums[j] + nums[k];
                if (temp > 0) {
                    k--;
                } else if (temp < 0) {
                    j++;
                } else {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[k]);
                    res.add(list);
                    // 去重
                    while (j<k && nums[j]==nums[j+1]) {
                        j++;
                    }
                    while (j<k && nums[k]==nums[k-1]) {
                        k--;
                    }
                    k--;
                    j++;
                }
            }
        }
        return res;
    }
}
```



### 二分法

#### [33.搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)

```java
class Solution {
    /*
     旋转数组二分
     二分同时需要考虑mid在左右哪一段
     分四种情况
     例：5 6 7 8 9 0 1 2 3 4
     mid在左段（nums[lo]<=nums[mid]）:
        target在mid左边（nums[lo]<=target<nums[mid]）
        target在mid右边
     mid在右段:
        target在mid左边
        target在mid右边（nums[mid]<target<=nums[hi]）
     */
    public int search(int[] nums, int target) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo <= hi) {
            int mid = (lo + hi)/2;
            if (target == nums[mid]) {
                return mid;
            }
            if (nums[lo] <= nums[mid]) {
                if (nums[lo] <= target && target < nums[mid]) {
                    hi = mid -1;
                } else {
                    lo = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[hi]) {
                    lo = mid + 1;
                } else {
                    hi = mid -1;
                }
            }
        }
        return -1;
    }
}
```



#### [162.寻找峰值](https://leetcode-cn.com/problems/find-peak-element)

```java
class Solution {
    /*
    二分法
    定论证明：nums[-1] = nums[n] = -∞，这就代表着 往递增的方向上，二分，一定能找到山峰，往递减的方向可能找到，也可能找不到。
     */
    public int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid =  (left + right) / 2;
            if (nums[mid] > nums[mid + 1]) {
                // 判断 nums[mid] > nums[mid + 1] ，所以 nums[mid] 可能是一个峰值， r=mid-1 那就错过 mid这个峰值了。
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```



#### [69.Sqrt(x)](https://leetcode-cn.com/problems/sqrtx)

```java
class Solution {
    // 二分法
    public int mySqrt(int x) {
        if (x==0 || x==1) {
            return x;
        }
        long left = 0;
        long right = x;
        while (left <= right) {
            long mid = (right + left ) / 2;
            long tmp = mid*mid;
            if (tmp > x) {
                right = mid - 1;
            } else if (tmp < x){
                left = mid+1;
            } else {
                return (int)mid;
            }
        }

        // mid = (right + left )/2，退出while条件是 left > right,
        // 所以最后返回 left - 1
        return (int)left - 1;
    }

    // 牛顿法，可以自己控制保留几位小数
    int s;
    public int _mySqrt(int x) {
        s=x;
        if(x==0) {
            return 0;
        }
        double res = sqrts(x);
        // 控制保留几位有效数字
        DecimalFormat df = new DecimalFormat("###.000"); //保留三位有效数字（四舍五入）
        return (int)res;
    }
    public double sqrts(double x){
        double res = (x + s / x) / 2;
        if (res == x) {
            return x;
        } else {
            return sqrts(res);
        }
    }
}
```



### 滑动窗口

#### [3.无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)

```java
class Solution {
    /*
    abcabcbb
    滑动窗口

    低效率：使用s.contain来判断，用s的left,right截取来维持滑动窗口
    left,right维持一个窗口，max维护最大值
    right每次往前移动，然后拿出最新的那个字符c
    当最新的字符c包含在窗口里面，那就移动left直到窗口不包含c
    !s(left,right).contain(c) {
        max = Math.max(s(left,right+1).len,max)
    } else {
        while(!s(left,right).contain(c)) {
            left++;
        }
    }

    高效率：使用map.contain来判断，使用left,right截取来维持滑动窗口，用map记录s.charAt(index),index
    right每次往前移动，然后拿出最新的那个字符c
    当最新的字符c包含在窗口里面，那就从map里面取出c的位置，left = index(c)+1，注意：c的位置可能在left的左边，所以要判断一下大小(abba)
    再放入最新的c，然后计算max
     */
    public int lengthOfLongestSubstring(String s) {
        int max = 0;
        Map<Character, Integer> map = new HashMap<>();
        for (int left = 0,right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            if (map.containsKey(c)) {
                // abba  c的位置可能在left的左边，所以要判断一下大小
                left = Math.max(map.get(c)+1, left);
            }
            // put之后会把原来的值覆盖了，map里面永远只有一个c
            map.put(c, right);
            max = Math.max(max, right-left+1);
        }
        return max;
    }

    public int lengthOfLongestSubstring1(String s) {
        int max = 0;
        for (int left = 0,right = 0; right < s.length(); right++) {
            String c = s.substring(right, right + 1);
            String String = s.substring(left, right);
            if (!String.contains(c)) {
                max = Math.max(String.length() + 1, max);
            } else {
                while (String.contains(c)) {
                    left++;
                    String = s.substring(left, right);
                }
            }
        }
        return max;
    }
}
```



#### [76.最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring)

```java
class Solution {
    public static String minWindow(String s, String t) {
        //首先创建的是need数组表示每个字符在t中需要的数量，用ASCII码来保存
        //加入need[76] = 2，表明ASCII码为76的这个字符在目标字符串t中需要两个，如果是负数表明当前字符串在窗口中是多余的，需要过滤掉
        int[] need = new int[128];
        //按照字符串t的内容向need中添加元素
        for (int i = 0; i < t.length(); i++) {
            need[t.charAt(i)]++;
        }
        /*
        l: 滑动窗口左边界
        r: 滑动窗口右边界
        size: 窗口的长度
        count: 当次遍历中还需要几个字符才能够满足包含t中所有字符的条件，最大也就是t的长度
        start: 如果有效更新滑动窗口，记录这个窗口的起始位置，方便后续找子串用
         */
        int l = 0, r = 0, minSize = Integer.MAX_VALUE, count = t.length(), start = 0;
        //循环条件右边界不超过s的长度
        while (r < s.length()) {
            char c = s.charAt(r);
            //表示t中包含当前遍历到的这个c字符，更新目前所需要的count数大小，应该减少一个
            if (need[c] > 0) {
                count--;
            }
            //无论这个字符是否包含在t中，need[]数组中对应那个字符的计数都减少1，利用正负区分这个字符是多余的还是有用的
            need[c]--;
            //count==0说明当前的窗口已经满足了包含t所需所有字符的条件
            if (count == 0) {
                //如果左边界这个字符对应的值在need[]数组中小于0，说明他是一个多余元素，不包含在t内
                while (l < r && need[s.charAt(l)] < 0) {
                    //在need[]数组中维护更新这个值，增加1
                    need[s.charAt(l)]++;
                    //左边界向右移，过滤掉这个元素
                    l++;
                }
                //如果当前的这个窗口值比之前维护的窗口值更小，需要进行更新
                if (r - l + 1 < minSize) {
                    //更新窗口值
                    minSize = r - l + 1;
                    //更新窗口起始位置，方便之后找到这个位置返回结果
                    start = l;
                }
                //先将l位置的字符计数重新加1
                need[s.charAt(l)]++;
                //重新维护左边界值和当前所需字符的值count
                l++;
                count++;
            }
            //右移边界，开始下一次循环
            r++;
        }
        return minSize == Integer.MAX_VALUE ? "" : s.substring(start, start + minSize);
    }

    /*
    滑动窗口解法
    hs 维护s字符串中滑动窗口中各个字符出现的次数
     */
    public String _minWindow(String s, String t) {
        // 维护s字符串中滑动窗口中各个字符出现的次数
        HashMap<Character,Integer> hs = new HashMap<Character,Integer>();
        // 维护t字符串各个字符出现多少次
        HashMap<Character,Integer> ht = new HashMap<Character,Integer>();
        // 遍历t字符串，用ht哈希表记录t字符串各个字符出现的次数。
        for(int i = 0;i < t.length();i ++){
            ht.put(t.charAt(i),ht.getOrDefault(t.charAt(i), 0) + 1);
        }
        String ans = "";
        int minLen = Integer.MAX_VALUE;
        // 有多少个元素符合
        int count = 0;
        for(int i = 0,j = 0;i < s.length();i ++) {
            hs.put(s.charAt(i), hs.getOrDefault(s.charAt(i), 0) + 1);
            if(ht.containsKey(s.charAt(i)) && hs.get(s.charAt(i)) <= ht.get(s.charAt(i))){
                count ++;
            }
            while(j < i && (!ht.containsKey(s.charAt(j)) || hs.get(s.charAt(j)) > ht.get(s.charAt(j)))) {
                hs.put(s.charAt(j), hs.get(s.charAt(j)) - 1);
                j++;
            }
            if(count == t.length() && i - j + 1 < minLen) {
                minLen = i - j + 1;
                ans = s.substring(j,i + 1);
            }
        }
        return ans;
    }
}
```



### DFS/BFS

```java
class Solution {
    //前序遍历
    public List<Integer> preorder(TreeNode root,List list) {
        if (root!=null){
            //先根再左再右
            System.out.println(root.val);
            list.add(root.val);
            preorder(root.left,list);
            preorder(root.right,list);
        }
        return list;
    }
    //中序遍历
    public List<Integer> inorder(TreeNode root,List list) {
        if (root!=null){
            //先左再根再右
            inorder(root.left,list);
            System.out.println(root.val);
            list.add(root.val);
            inorder(root.right,list);
        }
        return list;
    }
    //后序遍历
    public List<Integer> afterorder(TreeNode root,List list) {
        if (root!=null){
            //先左再右再根
            afterorder(root.left,list);
            afterorder(root.right,list);
            System.out.println(root.val);
            list.add(root.val);
        }
        return list;
    }
    /*
    前序遍历
    本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用Stack来模拟系统栈。
     */
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root==null){
            return list;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            //先根再左再右
            //因为是栈，所以右子树先入栈，所以左子树会先出栈先遍历
            System.out.println(node.val);
            list.add(node.val);
            if (node.right!=null){
                stack.add(node.right);
            }
            if (node.left!=null){
                stack.add(node.left);
            }
        }
        return list;
    }
    /*
    中序遍历
    定义一个栈，一个cur=root（TreeNode）
    从cur=root开始，不断将左子树入栈（stack.add(cur),cur=cur.left）     先左
    然后sout，list.add（node）                                       再根
    然后if:node.right!=null,cur=node.right                          再右
    */
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root==null){
            return list;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (!stack.isEmpty()||cur!=null){
            //先左
            while (cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            TreeNode node = stack.pop();
            //再根
            System.out.println(node.val);
            list.add(node.val);
            //再右
            if (node.right!=null){
                cur=node.right;
            }
        }
        return list;
    }
    /*
    后序遍历
    用两个栈，一个队列来实现
    前序遍历是：根左右
    修改前序遍历代码，左子树先入栈：根右左
    依次出栈，然后入队，返回队列：左右根
    */
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root==null){
            return list;
        }
        Stack<TreeNode> stack = new Stack<>();
        Stack<Integer> stack1 = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            //先根
            stack1.push(node.val);
            //再右
            if (node.left!=null){
                stack.push(node.left);
            }
            //再左
            if (node.right!=null){
                stack.push(node.right);
            }
        }
        //在这里不能对栈使用foreach，这样的话遍历顺序是从栈底到栈顶
        while (!stack1.isEmpty()) {
            System.out.println(stack1.peek());
            list.add(stack1.pop());
        }
        return list;
    }
}
```

```JAVA
//广度优先遍历
public void breadFirstSearch(TreeNode root){
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while(!queue.isEmpty()){
        TreeNode node = queue.remove();
        System.out.print(node.val);//遍历根结点
        if(node.left != null){
            queue.offer(node.left);//先将左子树入队
        }
        if(node.right != null){
            queue.offer(node.right);//再将右子树入队
        }
    }
}
```



#### [22.括号生成](https://leetcode-cn.com/problems/generate-parentheses)

```java
class Solution {
    /*
    类似回溯
    dfs生成所有组合
    每次进入dfs判断确定不符合的就直接return :（left > n || right > left）
    经过剪枝后，到达叶子节点，那就加入结果集
     */
    List<String> res = new ArrayList<>();
    int n;
    public List<String> _generateParenthesis(int n) {
        if (n == 0) {
            return res;
        }
        this.n = n;
        dfs("", 0, 0);
        return res;
    }
    private void dfs(String curStr, int left, int right) {
        // 剪枝
        if (left > n || right > left) {
            return;
        }
        // 到达叶子节点加入结果集
        if (left + right == n*2) {
            res.add(curStr);
            return;
        }
        dfs(curStr + "(", left+1, right);
        dfs(curStr + ")", left, right+1);
    }

    // 广度优先遍历
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        if (n == 0) {
            return res;
        }
        LinkedList<Node> queue = new LinkedList<>();
        queue.add(new Node("", n, n));
        while (!queue.isEmpty()) {
            Node curNode = queue.poll();
            if (curNode.left == 0 && curNode.right == 0) {
                res.add(curNode.res);
            }
            if (curNode.left > 0) {
                queue.add(new Node(curNode.res + "(", curNode.left - 1, curNode.right));
            }
            if (curNode.right > 0 && curNode.left < curNode.right) {
                queue.add(new Node(curNode.res + ")", curNode.left, curNode.right - 1));
            }
        }
        return res;
    }
    class Node {
        // 当前得到的字符串
        private String res;
        // 剩余左括号数量
        private int left;
        // 剩余右括号数量
        private int right;
        public Node(String str, int left, int right) {
            this.res = str;
            this.left = left;
            this.right = right;
        }
    }
}
```



#### 岛屿类问题

首先二叉树DFS遍历框架

```java
public void dfs(TreeNode root) {
	if(root == null) {
        return;
    }
    //做处理
    traverse(root.left)
    traverse(root.right)
}
```

网格遍历框架

```java
public void dfs(char[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return;
    }
    // 做处理
    // 不是岛屿直接返回
    if (grid[r][c] != '1') {
        return;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = '2';

    // 访问上下左右四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
public boolean inArea(char[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```

##### [200.岛屿数量](https://leetcode-cn.com/problems/number-of-islands)

思路：

```html
遍历“图“的每一个节点
遇到一个是岛屿就res++
然后从该节点开始dfs，将属于该岛屿的节点都标记为已经遍历 grid[r][c] = '2'
最终res++就是岛屿数量
```

```java
public int numIslands(char[][] grid) {
    int res = 0;
    for (int i=0; i<grid.length; i++) {
        for (int j=0; j< grid[0].length; j++) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j);
                res++;
            }
        }
    }
    return res;
}
public void dfs(char[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return;
    }
    // 做处理
    // 不是岛屿直接返回
    if (grid[r][c] != '1') {
        return;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = '2';

    // 访问上下左右四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
public boolean inArea(char[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```

##### [695.岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island)

思路：

```html
遍历“图“的每一个节点
遇到一个是岛屿就从该节点开始dfs，将属于该岛屿的节点都标记为已经遍历 grid[r][c] = '2'
dfs过程中不符合的（超出边界，不是岛屿）直接返回0
进入方法并且判断过没有超出边界，然后还判断了是岛屿，那面积就是 1 + dfs(上) + dfs(下) + dfs(左) + dfs(右);
```

```java
public int maxAreaOfIsland(int[][] grid) {
    int max = 0;
     (int i=0; i<grid.length; i++) {
        for (int j=0; j< grid[0].length; j++) {
            if (grid[i][j] == 1) {
                int area = dfs(grid, i, j);
                max = Math.max(area, max);
            }
        }
    }
    return max;
}
public int dfs(int[][] grid, int r, int c) {
    // 行row，列column
    // 判断 base case
    if(!inArea(grid, r, c)) {
        return 0;
    }
    // 不是岛屿返回0
    if (grid[r][c] != 1) {
        return 0;
    }
    // 将岛屿标记为已经遍历
    grid[r][c] = 2;

    // 访问上下左右四个节点
    // 进入方法并且判断过没有超出边界，然后还判断了是岛屿，那面积就是 1 + dfs(上) + dfs(下) + dfs(左) + dfs(右);
    return 1 + dfs(grid, r - 1, c)
        +dfs(grid, r + 1, c)
        +dfs(grid, r, c - 1)
        +dfs(grid, r, c + 1);
}
public boolean inArea(int[][] grid, int r, int c) {
    return 0<=r && r<grid.length && 0<=c && c<grid[0].length;
}
```



### 回溯

#### [79.单词搜索](https://leetcode-cn.com/problems/word-search)

```java
class Solution {
    /*
    回溯解法，类似岛屿问题，四个方向走
     */
    public boolean exist(char[][] board, String word) {
        // visited 数组防止重复访问
        int m = board.length;
        int n = board[0].length;
        boolean[][] visited = new boolean[m][n];
        // 每个格子都可能是起点
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board, i, j, 0, word, visited))
                    return true;
            }
        }
        return false;
    }
    public boolean dfs(char[][] a, int row, int col, int index, String word, boolean[][] visited) {
        // 不在网格内
        if (!inArea(a, row, col)) {
            return false;
        }
        // 重复访问
        if (visited[row][col]) {
            return false;
        }
        // 当前字符不等
        if (a[row][col] != word.charAt(index)) {
            return false;
        }
        // 如果word的每个字符都查找完了，直接返回true
        if (index == word.length() - 1) {
            return true;
        }
        // 当前字符匹配 做访问标记
        visited[row][col] = true;
        // 当前点四个方向匹配下一个字符
        boolean flag = dfs(a, row - 1, col, index + 1, word, visited) ||
                       dfs(a, row + 1, col, index + 1, word, visited) ||
                       dfs(a, row, col - 1, index + 1, word, visited) ||
                       dfs(a, row, col + 1, index + 1, word, visited);
        // 回溯修改当前不能访问的点 但是接下来的方向可以访问它
        visited[row][col] = false;
        return flag;
    }
    public boolean inArea(char[][] a, int i, int j) {
        return 0 <= i && i < a.length && 0 <= j && j < a[0].length;
    }
}
```



```java
// 回溯算法模板，适用于（排列，子集，组合）
res = List<List<Integer>>
list = LinkedList<Integer>
backtrack(选择列表):
    if 满足结束条件:
        res.add(list)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(选择列表)
        撤销选择
```

#### [93.复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses)

```java
class Solution {
    /*
    回溯解法
     */
    LinkedList<String> res = new LinkedList<>();
    LinkedList<String> list = new LinkedList<>();
    public List<String> restoreIpAddresses(String s) {
        if (s == null) {
            return res;
        }
        back(s, 0);
        return res;
    }
    private void back(String s, int pos) {
        // 当lis里面存了4个符合条件的字符串段组成IP
        // 注：必须要pos把s遍历完了，每个字节都用到了，才向res里面加入结果
        if (list.size() == 4) {
            if (pos == s.length()) {
                res.add(String.join(".", list));
            }
            return;
        }
        for (int i = 1; i <= 3; i++) {
            // 当字符串段要取得最后位置超出字符串时，剪枝
            // s.substring(pos, pos + i)，取到s.charAt(pos + i -1)， s.charAt(s.length() -1)是末端字节
            if (pos + i -1 > s.length() -1) {
                continue;
            }
            // 截取的字符串段，左并右开
            String segment = s.substring(pos, pos + i);
            // segment多个数字时首数字为0 || segment大于255，剪枝
            if (segment.startsWith("0") && segment.length() > 1 || Integer.parseInt(segment) > 255) {
                continue;
            }
            list.add(segment);
            back(s, pos + i);
            list.removeLast();
        }
    }

}
```

#### 全排列

##### [46.全排列](https://leetcode-cn.com/problems/permutations)

```java
public  class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        boolean[] used = new boolean[len];
        backtrack(nums, used);
        return res;
    }
    public void backtrack(int[] nums, boolean[] used) {
        if (list.size() == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }
        // 每次从 i=0开始，如果used就下一个
        for (int i = 0; i < nums.length; i++) {
            if (!used[i]) {
                list.add(nums[i]);
                used[i] = true;
                backtrack(nums, used);
                used[i] = false;
                list.removeLast();
            }
        }
    }
}
```



##### [47.全排列 II](https://leetcode-cn.com/problems/permutations-ii)

```java
// 在全排列的基础上添加剪枝
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        int len = nums.length;
        boolean[] used = new boolean[len];
        //  排序是剪枝的前提
        Arrays.sort(nums);
        backtrack(nums, used);
        return res;
    }
    private void backtrack(int[] nums, boolean[] used) {
        if (list.size() == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // 添加剪枝条件，起到去重效果
            if (!used[i] && !cut(nums, used, i)) {
                list.add(nums[i]);
                used[i] = true;
                backtrack(nums, used);
                used[i] = false;
                list.removeLast();
            }
        }
    }
    // 剪枝
    private boolean cut(int[] nums, boolean[] used, int i) {
        /*
        1,2,2,5
        1, 2(第1个2), 2(第2个2), 8 和 1, 2(第2个2), 2(第1个2), 8  是重复的
        所以使用 nums[i - 1] && !used[i - 1]作为条件来剪枝
        i>0 保证nums[i - 1]合法
         */
        return i > 0 && nums[i] == nums[i - 1] && !used[i - 1];
    }
}
```



#### 子集

##### [78.子集](https://leetcode-cn.com/problems/subsets)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0);
        return res;
    }
    public void backtrack(int[] nums, int start){
        res.add(new ArrayList<>(list));
        for (int i = start; i < nums.length; i++){
            list.add(nums[i]);
            backtrack(nums, i+1);
            list.removeLast();
        }
    }
}
```



##### [90.子集 II](https://leetcode-cn.com/problems/subsets-ii)

```java
// 在子集的基础上添加剪枝
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        // 添加used， 记录数字是否被使用过
        boolean[] used = new boolean[nums.length];
        backtrack(nums, used, 0);
        return res;
    }
    public void backtrack(int[] nums, boolean[] used, int start){
        res.add(new ArrayList<>(list));
        for (int i = start; i < nums.length; i++){
            if (!cut(nums, used, i)) {
                list.add(nums[i]);
                used[i] = true;
                backtrack(nums, used, i+1);
                used[i] = false;
                list.removeLast();
            }
        }
    }
    // 剪枝
    private boolean cut(int[] nums, boolean[] used, int i) {
        /*
        1,2,2,5,7,8
        1,2(第1个2),8 和 1,2(第2个2),8 是不可以的，但是 1,2,2是可以的
        所以使用 nums[i - 1] && !used[i - 1]作为条件来剪枝
        i>0 保证nums[i - 1]合法
         */
        return i > 0 && nums[i] == nums[i - 1] && !used[i - 1];
    }
}
```



#### 组合

##### [77.组合](https://leetcode-cn.com/problems/combinations)

```java
public class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backtrack(1, n, k);
        return res;
    }
    private void backtrack(int start, int n, int k) {
        if (k == list.size()) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i=start; i<=n; i++) {
            list.add(i);
            backtrack(i+1, n, k);
            list.removeLast();
        }
    }
}
```



##### [39.组合总和](https://leetcode-cn.com/problems/combination-sum)

```java
class Solution {
    /*
    同样的回溯算法，每次判断的满足条件是target=0
    注：当target<0那什么都不做就直接返回
    注：需要先给数组排序， 让target从小到大的减
    注：同一个位置的数字无限次使用，所以传给下一层 i
    递归传给下一层 target - candidates[i]
     */
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        // 需要先给数组排序， 让target从小到大的减
        Arrays.sort(candidates);
        backtrack(candidates, target, 0);
        return res;
    }
    private void backtrack(int[] candidates, int target, int start) {
        if (target < 0) {
            return;
        }
        if (target == 0) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            // 加个剪枝条件
            // 很明显已经target < candidates[i]了，后面target减下去肯定<0
            if (target < candidates[i]) {
                break;
            }
            list.add(candidates[i]);
            backtrack(candidates, target - candidates[i], i);
            list.removeLast();
        }
    }
}
```



##### [40.组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii)

```java
// 在组合总和的基础上添加剪枝
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> list = new LinkedList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        // 需要先给数组排序， 让target从小到大的减
        Arrays.sort(candidates);
        // 添加used， 记录数字是否被使用过
        boolean[] used = new boolean[candidates.length];
        backtrack(candidates, target, used, 0);
        return res;
    }
    private void backtrack(int[] candidates, int target, boolean[] use, int start) {
        if (target < 0) {
            return;
        }
        if (target == 0) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if (target < candidates[i]) {
                break;
            }
            if (!cut(candidates, i, use)) {
                list.add(candidates[i]);
                use[i] = true;
                // 注：同一个位置的数字只能使用一次，所以传给下一层 i+1
                backtrack(candidates, target - candidates[i], use, i+1);
                use[i] = false;
                list.removeLast();
            }
        }
    }
    // 剪枝
    private boolean cut(int[] candidates, int i, boolean[] use) {
        /*
        1,2,2,5,7,8
        1,2(第1个2),8 和 1,2(第2个2),8 是不可以的，但是 1,2,2是可以的
        所以使用 nums[i - 1] && !used[i - 1]作为条件来剪枝
        i>0 保证nums[i - 1]合法
         */
        return i > 0 && candidates[i] == candidates[i - 1] && !use[i - 1];
    }
}
```



### 排序

#### 快排

```java
public class QuickSort {
    public static void quickSort(int[] arr,int low,int high){
        int i,j,temp,t;
        if(low>high){
            return;
        }
        i=low;
        j=high;
        //temp就是基准位
        temp = arr[low];
 
        while (i<j) {
            //先看右边，依次往左递减
            while (temp<=arr[j]&&i<j) {
                j--;
            }
            //再看左边，依次往右递增
            while (temp>=arr[i]&&i<j) {
                i++;
            }
            //如果满足条件则交换
            if (i<j) {
                t = arr[j];
                arr[j] = arr[i];
                arr[i] = t;
            }
 
        }
        //最后将基准为与i和j相等位置的数字交换
         arr[low] = arr[i];
         arr[i] = temp;
        //递归调用左半数组
        quickSort(arr, low, j-1);
        //递归调用右半数组
        quickSort(arr, j+1, high);
    }
    public static void main(String[] args){
        int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19};
        quickSort(arr, 0, arr.length-1);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
```



##### [215.数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)

```java
class Solution {
    /*
    快速选择(切分)算法：
    findK() {
        寻找第K大的数就是寻找”排序“数组中第num.len-K个数
        target = len-K
        left = 0
        right = len -1;
        while(true) {
            int index = partition(num[],left,right)
            if (index > target) {
                right = index -1
            } else if (index < target) {
                left = index+1
            } else {
                return nums[target]
            }
        }
    }
    partition(num[],left,right) {
        使num[left]大于左边的数，小于右边的数
        返回num[left]的下标
    }
     */
    public int findKthLargest(int[] nums, int k) {
        int length = nums.length;
        int target = length-k;
        int left = 0;
        int right = length -1;
        while(true) {
            int index = partition(nums, left, right);
            if (index > target) {
                right = index -1;
            } else if (index < target) {
                left = index+1;
            } else {
                return nums[target];
            }
        }
    }
    public int partition(int[] nums, int left, int right) {
        // temp就是基准位
        int pivot = nums[left];
        int i = left;
        int j = right;
        while (i<j) {
            // 从右边开始找到比基准数小的
            while (i<j && nums[j]>=pivot) {
                j--;
            }
            // 从左边开始找到比基准数大的
            while (i<j && nums[i]<=pivot) {
                i++;
            }
            // 此时满足条件（nums[j] < pivot < nums[i]），交换
            swap(nums, i, j);
        }
        // 最终i，j移动到一个位置，这个位置左边的数<=pivot,右边的数>=pivot
        // 最后将基准为与i和j相等位置的数字交换
        swap(nums, left, i);
        return  i;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    /**
     * 小顶堆实现（当前节点小于等于左右孩子节点）
     * for (int num : nums) {
     *     heap.add(num);
     *     if (heap.size() > k) {
     *         heap.poll();
     *      }
     * }
     * return heap.peek();
     */
    //小顶堆实现
    public int findKthLargest1(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int num : nums) {
            minHeap.add(num);
            if (minHeap.size()>k){
                minHeap.poll();
            }
        }
        return minHeap.peek();
    }
}
```



#### 冒泡排序

```java
public static int[] bubbleSort(int[] array) {
    if (array.length == 0)
        return array;
    for (int i = 0; i < array.length; i++)
        for (int j = 0; j < array.length - 1 - i; j++)
            if (array[j + 1] < array[j]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
    return array;
}
```

#### 选择排序

```java
public static int[] selectionSort(int[] array) {
    if (array.length == 0)
        return array;
    for (int i = 0; i < array.length; i++) {
        int minIndex = i;
        for (int j = i; j < array.length; j++) {
            if (array[j] < array[minIndex]) //找到最小的数
                minIndex = j; //将最小数的索引保存
        }
        int temp = array[minIndex];
        array[minIndex] = array[i];
        array[i] = temp;
    }
    return array;
}
```

#### 插入排序

```java
public static int[] insertionSort(int[] array) {
    if (array.length == 0)
        return array;
    int current;
    for (int i = 0; i < array.length - 1; i++) {
        current = array[i + 1];
        int preIndex = i;
        while (preIndex >= 0 && current < array[preIndex]) {
            array[preIndex + 1] = array[preIndex];
            preIndex--;
        }
        array[preIndex + 1] = current;
    }
    return array;
}

```

#### 希尔排序

```java
public static int[] ShellSort(int[] array) {
    int len = array.length;
    int temp, gap = len / 2;
    while (gap > 0) {
        for (int i = gap; i < len; i++) {
            temp = array[i];
            int preIndex = i - gap;
            while (preIndex >= 0 && array[preIndex] > temp) {
                array[preIndex + gap] = array[preIndex];
                preIndex -= gap;
            }
            array[preIndex + gap] = temp;
        }
        gap /= 2;
    }
    return array;
}

```

#### 归并排序

```java
 static int[] MergeSort(int[] array) {
    if (array.length < 2) return array;
    int mid = array.length / 2;
    int[] left = Arrays.copyOfRange(array, 0, mid);
    int[] right = Arrays.copyOfRange(array, mid, array.length);
    return merge(MergeSort(left), MergeSort(right));
}
// 归并排序——将两段排序好的数组结合成一个排序数组
public static int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    for (int index = 0, i = 0, j = 0; index < result.length; index++) {
        if (i >= left.length)
            result[index] = right[j++];
        else if (j >= right.length)
            result[index] = left[i++];
        else if (left[i] > right[j])
            result[index] = right[j++];
        else
            result[index] = left[i++];
    }
    return result;
}
```

### 字典序

#### [440.字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order)

```java
class Solution {
    /*
    字典序解法
    1.确定指定前缀下所有子节点数：用下一个前缀的起点减去当前前缀的起点
    2.第k个数在当前前缀下：往子树里面去看
    3.第k个数不在当前前缀下：扩大前缀
     */
    public int findKthNumber(int n, int k) {
        // 已经经过的元素个数, 开始一个元素都没有经过, 所以个数为 0
        int cnt = 0;
        // 第一个元素 (经过 i 个元素, 当前 num 是第 i + 1 元素)
        int num = 1;
        // 要找到第 k 个元素, 需要经过 k - 1 个元素
        // 经过了 k - 1 个元素找到了第 k 个元素
        while (cnt != k - 1) {
            int temp = count((long)num, n);    // 以 num 为根, 以 n 为最大值的十叉树的元素总个数
            if (cnt + temp >= k) {       // 以 num 为根的十叉树内有第 k 个元素
                num *= 10;
                cnt++;
            } else if (cnt + temp < k) { // 以 num 为根的十叉树内没有第 k 个元素
                num++;
                cnt += temp;
            }
        }
        return num;
    }
    /*
    以当前数字为根的十叉树的元素总个数 (包括当前数字)
    num 当前数字 (需要先 cast 成 long, 因为 num*10 可能导致 int 溢出)
    n   数字的最大值
     */
    private int count(long num, int n) {
        int cnt = 0;     // 元素总个数
        int width = 1;   // 当前层数的宽度, 第一层只有 num 一个元素, 所以第一层宽度为 1
        while (true) {
            if (num + width - 1 <= n) {   // n 的值大于等于当前层的最大值, 说明当前层数的个数可以全部添加
                cnt += width;
                num *= 10;
                width *= 10;
            } else {                      // n 的值小于当前层的最大值则只能添加部分个数或者不添加, 并跳出循环
                if (n - num >= 0) {
                    cnt += n - num + 1;
                }
                break;
            }
        }
        return cnt;
    }
}
```





















## 设计模式

### 生产者消费者

```java

```

